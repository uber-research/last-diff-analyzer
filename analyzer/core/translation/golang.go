//  Copyright (c) 2023 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package translation

import (
	"errors"
	"fmt"
	"strings"

	"analyzer/core/mast"
	ts "analyzer/core/treesitter"
)

// GoTranslator translates Go AST generated by tree-sitter to MAST AST.
type GoTranslator struct{}

// Translate handles special cases for Go AST, other node types are handled by GenericTranslator.
// The full documentation of the Go AST can be found at
// https://github.com/tree-sitter/tree-sitter-go/blob/master/src/node-types.json and
// https://github.com/tree-sitter/tree-sitter-go/blob/master/src/grammar.json
func (t *GoTranslator) Translate(node *ts.Node) (mast.Node, error) {
	// the translations of some nodes can be shared across different languages, where the only difference is the name
	// for node.Type. Therefore, we first handle name rewrites here.
	switch node.Type {
	case "source_file":
		node.Type = "root"
	case "package_identifier", "field_identifier", "type_identifier", "blank_identifier",
		"dot", "label_name":
		// the nodes above are just special identifiers in Go AST.
		node.Type = "identifier"
	case "nil":
		node.Type = "null_literal"
	case "interpreted_string_literal":
		node.Type = "string_literal"
	case "rune_literal":
		node.Type = "character_literal"
	case "selector_expression", "qualified_type":
		// selector_expression is modeled as an access_path in MAST.
		// qualified_type represents types like "pkg.Type". In MAST we model this as access_path node.
		node.Type = "access_path"
	case "type_case", "default_case":
		// type_case is just a specialized version of expression_case, where the values could be types instead
		// of expressions. However, in MAST all type nodes are designed to be mast.Expression nodes, therefore here
		// the translations can share the same logic.
		// default_case is also a specialized version of expression_case, where the value field does not exist.
		node.Type = "expression_case"
	case "import_spec_list", "field_declaration_list", "expression_list", "argument_list", "parameter_list",
		"var_declaration", "const_declaration", "type_declaration":
		// (1) All the list nodes share the same logic: simply translate all children and group the translated nodes
		//     together in a mast.TempGroupNode;
		// (2) var_declaration and const_declaration are just wrapper nodes in tree-sitter, where they contain multiple
		//     var_spec or const_spec node. The real translations happen in var_spec and const_spec, therefore here we
		//     simply translate all children and return the grouped nodes in mast.TempGroupNode, which is the same as
		//     the handling for lists;
		// (3) type_declaration is the same as var_declaration except that each child of it could either be a type_alias
		//     node or a type_spec node (anonymous).
		// Note that an empty list is also possible and allowed in Go. For example, var_declaration could be empty,
		// ("var ()" or "const ()"). If that is the case, the translation simply returns a mast.TempGroupNode with an
		// empty slice. When the node is un-grouped in upper-levels, the empty declaration node will simply be dropped.
		node.Type = "list"
	case "keyed_element":
		// keyed_element is the same as key_value_pair.
		node.Type = "key_value_pair"
	}

	// here we delegate the translation to unexported methods.
	switch node.Type {
	case "package_clause":
		return t.packageClause(node)
	case "import_declaration":
		return t.importDeclaration(node)
	case "import_spec":
		return t.importSpec(node)
	case "slice_expression":
		return t.sliceExpression(node)
	case "variadic_argument":
		return t.variadicArgument(node)
	case "call_expression":
		return t.callExpression(node)
	case "raw_string_literal":
		return t.rawStringLiteral(node)
	case "imaginary_literal":
		return t.imaginaryLiteral(node)
	case "pointer_type":
		return t.pointerType(node)
	case "array_type", "slice_type", "implicit_length_array_type":
		return t.arrayType(node)
	case "map_type":
		return t.mapType(node)
	case "parenthesized_type":
		return t.parenthesizedType(node)
	case "channel_type":
		return t.channelType(node)
	case "type_assertion_expression":
		return t.typeAssertionExpression(node)
	case "defer_statement":
		return t.deferStatement(node)
	case "goto_statement":
		return t.gotoStatement(node)
	case "fallthrough_statement":
		return t.fallthroughStatement(node)
	case "send_statement":
		return t.sendStatement(node)
	case "go_statement":
		return t.goStatement(node)
	case "inc_statement", "dec_statement":
		return t.incDecStatement(node)
	case "assignment_statement", "short_var_declaration":
		// short_var_declaration is the same as assignment_statement in Go, except the IsShortVarDeclaration flag will
		// be set. This design follows the ast package from golang.
		return t.assignmentStatement(node)
	case "expression_switch_statement":
		return t.expressionSwitchStatement(node)
	case "expression_case":
		return t.expressionCase(node)
	case "type_switch_statement":
		return t.typeSwitchStatement(node)
	case "type_spec", "type_alias":
		// type_alias node is the same as type_spec where the only difference is that IsAlias is set to true for
		// type_alias.
		return t.typeSpec(node)
	case "var_spec", "const_spec":
		// var_spec node is the same as const_spec where the only difference is that IsConst is set to
		// true for const_spec. A subtle difference between the tree structure is that const_spec allows
		// both type and value be empty (e.g., "const (a = iota; b)") and disallows type without expressions.
		// However, our translation for var_spec is generic enough to handle those differences.
		return t.varSpec(node)
	case "field_declaration":
		return t.fieldDeclaration(node)
	case "struct_type":
		return t.structType(node)
	case "parameter_declaration", "variadic_parameter_declaration":
		// variadic_parameter_declaration is a special case of parameter_declaration, the translation of
		// parameter_declaration is general enough to take care of variadic_parameter_declaration.
		return t.parameterDeclaration(node)
	case "function_type":
		return t.functionType(node)
	case "for_statement":
		return t.forStatement(node)
	case "for_clause":
		return t.forClause(node)
	case "range_clause":
		return t.rangeClause(node)
	case "element":
		return t.element(node)
	case "composite_literal":
		return t.compositeLiteral(node)
	case "select_statement":
		return t.selectStatement(node)
	case "communication_case":
		return t.communicationCase(node)
	case "receive_statement":
		return t.receiveStatement(node)
	case "func_literal":
		return t.funcLiteral(node)
	case "function_declaration", "method_declaration", "method_spec":
		// (1) method_declaration is a special case for function_declaration where there is an additional receiver field;
		// (2) method_spec is another special case for method_declaration where there are no receivers or body.
		return t.functionDeclaration(node)
	case "interface_type":
		return t.interfaceType(node)
	case "type_conversion_expression":
		return t.typeConversionExpression(node)
	// fallback to generic translation
	default:
		return (&GenericTranslator{Lang: t}).Translate(node)
	}
}

// a few helper functions

// translateParameters is a helper function that handles translation of a list of parameter declarations. Specifically,
// it handles the following forms properly:
// (1) a parameter_list containing single or multiple parameter_declaration nodes (e.g., "func (A, B) (C, D)" or
//
//	"func (A, B) (c C)"). This will be translated to a slice of *mast.ParameterDeclaration nodes.
//
// (2) a simple type, if only a single return type is given without a name (e.g., "func (A, B) C"), for better
//
//	unification we wrap it inside a mast.ParameterDeclaration.
//
// In any case, this function returns a slice of mast.Declaration, where each element will always be
// *mast.ParameterDeclaration. The up-casting is for better compatibility with other language constructs such as Java
// which has a language-specific parameter declaration node. Also, nil is returned if the parameter list is empty.
func translateParameters(t Translator, parameter *ts.Node) ([]mast.Declaration, error) {
	// We un-group the nodes here since parameter could be a parameter_list node and each parameter_declaration could
	// also return multiple mast.ParameterDeclaration nodes grouped by mast.TempGroupNode (due to "func (a, b SomeType)").
	translated, err := translateNodes(t, []*ts.Node{parameter}, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	// early return if it is an empty parameter list.
	if len(translated) == 0 {
		return nil, nil
	}

	cast := make([]mast.Declaration, len(translated))

	for i, t := range translated {
		switch n := t.(type) {
		case *mast.ParameterDeclaration:
			cast[i] = n
		case mast.Expression:
			// It can only contain an expression node if only a simple type is given (i.e., "func () SomeType"), which
			// means the parameter list can only contain one element.
			if len(translated) != 1 {
				return nil, errors.New("parameter list contains more than one element, but a simple type is detected")
			}
			// wrap it inside a mast.ParameterDeclaration
			cast[i] = &mast.ParameterDeclaration{Type: n}
		default:
			return nil, nodeTypeError(t)
		}
	}

	return cast, nil
}

// packageClause translates package_clause to mast.PackageDeclaration.
func (t *GoTranslator) packageClause(node *ts.Node) (mast.Node, error) {
	// package_clause has only one child: identifier (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	identifier, ok := translated.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.PackageDeclaration{
		Name: identifier,
	}

	return result, nil
}

// import_declaration node has the following structure:
// import_declaration:
//
//	import_spec_list (optional, only present if more than one import_spec nodes exist):
//	  import_spec: ...
//	  import_spec: ...
//	  ...
//
// when translating import_declaration, we simply pass the translation down to the bottom layer (import_spec),
// and return the translated mast.ImportDeclaration node from there. If import_spec_list is present, we make use of
// mast.TempGroupNode to group the translated mast.ImportDeclaration nodes and return it. The translation for
// import_declaration simply skips this level and pass the translated node up.
// At the higher level (mast.Root level), the TempGroupNode will be "un-grouped".
// See mast.TempGroupNode for details.
func (t *GoTranslator) importDeclaration(node *ts.Node) (mast.Node, error) {
	// import_declaration has only one child: import_spec or import_spec_list
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}
	return t.Translate(node.Children[0])
}

// importSpec translates an import_spec ts.Node to mast.ImportDeclaration.
func (t *GoTranslator) importSpec(node *ts.Node) (mast.Node, error) {
	// import_spec may have up to two children:
	// for import with alias (import alias "package"): name (optional), path
	// for plain import (import "package"): path
	alias, path := node.ChildByField("name"), node.ChildByField("path")

	// only name field is optional
	if path == nil {
		return nil, nilChildError(node)
	}

	result := &mast.ImportDeclaration{}

	// translate and cast alias
	if alias != nil {
		translatedAlias, err := t.Translate(alias)
		if err != nil {
			return nil, err
		}
		castAlias, ok := translatedAlias.(*mast.Identifier)
		if !ok {
			return nil, nodeTypeError(translatedAlias)
		}
		result.Alias = castAlias
	}

	// translate and cast path
	translatedPath, err := t.Translate(path)
	if err != nil {
		return nil, err
	}
	castPath, ok := translatedPath.(*mast.StringLiteral)
	if !ok {
		return nil, nodeTypeError(translatedPath)
	}
	result.Package = castPath

	return result, nil
}

// typeSpec translates type_spec and type_alias to mast.GoTypeDeclaration.
func (t *GoTranslator) typeSpec(node *ts.Node) (mast.Node, error) {
	// type_spec / type_alias must have 2 children: name, type.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	name, typeNode := node.Children[0], node.Children[1]

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}

	result := &mast.GoTypeDeclaration{
		Name: castName,
		Type: castType,
	}

	// finally set the flag if it is a type_alias node
	if node.Type == "type_alias" {
		result.IsAlias = true
	}

	return result, nil
}

// varSpec translates var_spec to a single mast.VariableDeclaration node or multiple mast.VariableDeclaration nodes
// grouped by mast.TempGroupNode. Similar to the translations of import_spec nodes, this flattens the grouped variable
// declaration (e.g., "var (a, b = 1, 2; c = 3)") into individual mast.GoVariableDeclaration nodes (e.g.,
// "var a = 1; var b = 2; var c = 3;").
func (t *GoTranslator) varSpec(node *ts.Node) (mast.Node, error) {
	// var_spec must have at least 1 children: list of names, type (optional), value (optional).
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	names, typeNode, value := node.ChildrenByField("name"), node.ChildByField("type"), node.ChildByField("value")

	translatedNames, err := translateNodes(t, names, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	castNames, err := toIdentifiers(translatedNames)
	if err != nil {
		return nil, err
	}

	var castType mast.Expression
	if typeNode != nil {
		// translate and cast type
		translatedType, err := t.Translate(typeNode)
		if err != nil {
			return nil, err
		}
		n, ok := translatedType.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedType)
		}
		castType = n
	}

	var castValues []mast.Expression
	if value != nil {
		// the value could be an expression_list node which will be translated to a slice of Expression nodes grouped by
		// mast.TempGroupNode, therefore here we un-group them.
		translatedValues, err := translateNodes(t, []*ts.Node{value}, true /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		n, err := toExpressions(translatedValues)
		if err != nil {
			return nil, err
		}
		castValues = n
	}

	// Go allows imbalanced variable declarations, such as "var x, y int = foo()", provided that the RHS is "a single
	// multi-valued expression such as a function call, a channel or map operation, or a type assertion".
	// See https://golang.org/ref/spec#Assignments for detailed explanations.
	// Note that if RHS does not exist, we proceed to normal process (split the declaration to multiple variable
	// declarations with no initial value).
	if castValues != nil && len(castNames) != len(castValues) {
		// RHS must be a single multi-value expression.
		if len(castValues) != 1 {
			return nil, fmt.Errorf("mismatched number of identifiers and values for node %q: %v != %v",
				node.Type, len(castNames), len(castValues))
		}
		result := &mast.VariableDeclaration{
			Names: castNames,
			Type:  castType,
			Value: castValues[0],
		}
		return result, nil
	}

	result := &mast.TempGroupNode{}
	for i, name := range castNames {
		decl := &mast.VariableDeclaration{
			IsConst: strings.HasPrefix(node.Type, "const"),
			Names:   []*mast.Identifier{name},
			Type:    castType,
		}
		if castValues != nil {
			decl.Value = castValues[i]
		}
		result.Nodes = append(result.Nodes, decl)
	}

	return result, nil
}

// sliceExpression translates slice_expression to mast.GoSliceExpression
func (t *GoTranslator) sliceExpression(node *ts.Node) (mast.Node, error) {
	// slice_expression can have 1-4 children: operand, start (optional), end (optional), capacity (optional)
	if len(node.Children) < 1 || len(node.Children) > 4 {
		return nil, childrenNumberError(node)
	}

	// retrieve operand, start, end, and capacity ts.Node (or nil) and store them in a slice
	nodes := []*ts.Node{
		node.ChildByField("operand"),
		node.ChildByField("start"),
		node.ChildByField("end"),
		node.ChildByField("capacity"),
	}

	// translate children, ignoring nil nodes
	translated, err := translateNodes(t, nodes, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	result := &mast.GoSliceExpression{
		Operand:  expressions[0],
		Start:    expressions[1],
		End:      expressions[2],
		Capacity: expressions[3],
	}
	return result, nil
}

// callExpression translates call_expression to mast.CallExpression.
func (t *GoTranslator) callExpression(node *ts.Node) (mast.Node, error) {
	// call_expression must have two children: function and arguments
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	// the first expression is the function identifier (identifier or selector expression),
	// the rest are mast.Expression nodes for arguments.
	translated, err := translateNodes(t, node.Children, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	fn := expressions[0]
	if err := mast.SetCallKind(fn, mast.Function); err != nil {
		return nil, err
	}
	result := &mast.CallExpression{
		Function: fn,
	}

	// return early if no arguments are present
	if len(expressions) == 1 {
		return result, nil
	}

	result.Arguments = expressions[1:]
	return result, nil
}

// variadicArgument translates variadic_argument to mast.GoEllipsisExpression.
func (t *GoTranslator) variadicArgument(node *ts.Node) (mast.Node, error) {
	// variadic_argument must have one child: expression
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	expression, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.GoEllipsisExpression{
		Expr: expression,
	}
	return result, nil
}

// rawStringLiteral translates raw_string_literal to mast.StringLiteral.
func (t *GoTranslator) rawStringLiteral(node *ts.Node) (mast.Node, error) {
	result := &mast.StringLiteral{
		IsRaw: true,
		Value: node.Name,
	}
	return result, nil
}

// imaginaryLiteral translates imaginary_literal to mast.GoImaginaryLiteral.
func (t *GoTranslator) imaginaryLiteral(node *ts.Node) (mast.Node, error) {
	result := &mast.GoImaginaryLiteral{
		Value: node.Name,
	}
	return result, nil
}

// pointerType translates pointer_type to mast.GoPointerType.
func (t *GoTranslator) pointerType(node *ts.Node) (mast.Node, error) {
	// pointer_type must have one child: type (anonymous)
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	expression, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.GoPointerType{
		Type: expression,
	}
	return result, nil
}

// arrayType translates array_type/slice_type/implicit_length_array_type to mast.GoArrayType.
func (t *GoTranslator) arrayType(node *ts.Node) (mast.Node, error) {
	// array_type/slice_type/implicit_length_array_type must have 1 or 2 children: length (optional) and element.
	// Specifically, slice_type and implicit_length_array_type will _not_ have the length field, so we distinguish them
	// based on its type name.
	if len(node.Children) != 1 && len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	// fixed-length array type
	if len(expressions) == 2 {
		result := &mast.GoArrayType{
			Length:  expressions[0],
			Element: expressions[1],
		}
		return result, nil
	}

	// slice type or implicit_length_array_type
	result := &mast.GoArrayType{
		Element: expressions[0],
	}
	if node.Type == "implicit_length_array_type" {
		result.Length = &mast.StringLiteral{
			IsRaw: false,
			Value: "...",
		}
	}

	return result, nil
}

// mapType translates map_type to mast.GoMapType.
func (t *GoTranslator) mapType(node *ts.Node) (mast.Node, error) {
	// map_type must have two children: key, value.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	result := &mast.GoMapType{
		Key:   expressions[0],
		Value: expressions[1],
	}
	return result, nil
}

// parenthesizedType translates parenthesized_type to mast.GoParenthesizedType.
func (t *GoTranslator) parenthesizedType(node *ts.Node) (mast.Node, error) {
	// parenthesized_type can only have one child: type (anonymous)
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}

	castType, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.GoParenthesizedType{
		Type: castType,
	}

	return result, nil
}

// channelType translates channel_type to mast.GoChannelType.
func (t *GoTranslator) channelType(node *ts.Node) (mast.Node, error) {
	// channel_type can have 2-3 children (arrow can only appear once): arrow (optional), chan, arrow (optional), type.
	if len(node.Children) < 2 || len(node.Children) > 3 {
		return nil, childrenNumberError(node)
	}

	// we need to find out the relative positions of arrow and chan to determine the direction of the channel type.
	// To do this, whenever we see the arrow "<-", we check if we have seen "chan" already: yes means "chan <-"
	// and no means "<- chan". If we never see the arrow "<-", direction is the default mast.SendAndReceive.
	direction := mast.SendAndReceive
	seenChan := false
	for _, c := range node.Children {
		if c.Type == "chan" {
			seenChan = true
			continue
		}
		if c.Type == "<-" {
			if seenChan {
				direction = mast.SendOnly
			} else {
				direction = mast.ReceiveOnly
			}
		}
	}

	// translate the type
	translated, err := t.Translate(node.Children[len(node.Children)-1])
	if err != nil {
		return nil, err
	}
	expression, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.GoChannelType{
		Direction: direction,
		Type:      expression,
	}

	return result, nil
}

// typeAssertionExpression translates type_assertion_expression to mast.GoTypeAssertionExpression.
func (t *GoTranslator) typeAssertionExpression(node *ts.Node) (mast.Node, error) {
	// type_assertion_expression must have two children: operand, type.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	result := &mast.GoTypeAssertionExpression{
		Operand: expressions[0],
		Type:    expressions[1],
	}

	return result, nil
}

// deferStatement translates defer_statement to mast.GoDeferStatement.
func (t *GoTranslator) deferStatement(node *ts.Node) (mast.Node, error) {
	// defer_statement must have one children: expression (anonymous)
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	expression, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.GoDeferStatement{
		Expr: expression,
	}

	return result, nil
}

// gotoStatement translates goto_statement to mast.GoGotoStatement.
func (t *GoTranslator) gotoStatement(node *ts.Node) (mast.Node, error) {
	// goto_statement must have 1 children: label (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	label, ok := translated.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translated)
	}
	label.Kind = mast.Label

	result := &mast.GoGotoStatement{
		Label: label,
	}

	return result, nil
}

// fallthroughStatement translates fallthrough_statement to mast.GoFallthroughStatement.
func (t *GoTranslator) fallthroughStatement(node *ts.Node) (mast.Node, error) {
	// fallthrough_statement cannot have children.
	if len(node.Children) != 0 {
		return nil, childrenNumberError(node)
	}

	return &mast.GoFallthroughStatement{}, nil
}

// sendStatement translates send_statement to mast.SendStatement.
func (t *GoTranslator) sendStatement(node *ts.Node) (mast.Node, error) {
	// send_statement must have two children: channel, value.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	result := &mast.GoSendStatement{
		Channel: expressions[0],
		Value:   expressions[1],
	}

	return result, nil
}

// goStatement translates go_statement to mast.GoStatement.
func (t *GoTranslator) goStatement(node *ts.Node) (mast.Node, error) {
	// go_statement must have one child: call.
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	call, ok := translated.(*mast.CallExpression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.GoGoStatement{
		Call: call,
	}

	return result, nil
}

// assignmentStatement translates assignment_statement to a mast.AssignmentExpression wrapped in
// mast.ExpressionStatement.
func (t *GoTranslator) assignmentStatement(node *ts.Node) (mast.Node, error) {
	// Go does not support assignment expressions, instead you can only write assignments in assignment statements.
	// For better unification of MAST nodes, here we translate it to mast.AssignmentExpression and then wrap it in
	// mast.ExpressionStatement.

	// set the IsShortVarDeclaration flag
	isShortVarDeclaration := (node.Type == "short_var_declaration")

	node.Type = "assignment_expression"
	translated, err := t.Translate(node)
	if err != nil {
		return nil, err
	}
	expression, ok := translated.(*mast.AssignmentExpression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	expression.IsShortVarDeclaration = isShortVarDeclaration

	result := &mast.ExpressionStatement{
		Expr: expression,
	}

	return result, nil
}

// expressionSwitchStatement translates expression_switch_statement to mast.SwitchStatement.
func (t *GoTranslator) expressionSwitchStatement(node *ts.Node) (mast.Node, error) {
	// expression_switch_statement can have any number of children, so we skip the check here.
	// the organization of expression_switch_statement is as follows:
	// initializer (optional), value (optional), list of expression_case nodes (anonymous).
	result := &mast.SwitchStatement{}
	initializer, value := node.ChildByField("initializer"), node.ChildByField("value")

	// all expression_case nodes following the initializer and value nodes are anonymous, so here we keep track of
	// the start index of the case expressions, which depends on whether initializer / value is present or not.
	caseStartIndex := 0

	// translate and cast initializer
	if initializer != nil {
		translatedInitializer, err := t.Translate(initializer)
		if err != nil {
			return nil, err
		}
		castInitializer, ok := translatedInitializer.(mast.Statement)
		if !ok {
			return nil, nodeTypeError(translatedInitializer)
		}
		result.Initializer = castInitializer

		caseStartIndex++
	}

	// translate and cast the value
	if value != nil {
		translatedValue, err := t.Translate(value)
		if err != nil {
			return nil, err
		}
		castValue, ok := translatedValue.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedValue)
		}

		result.Value = castValue

		caseStartIndex++
	}

	// no case statements present
	if caseStartIndex == len(node.Children) {
		return result, nil
	}

	// translate and cast case statements
	translated, err := translateNodes(t, node.Children[caseStartIndex:], false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	cases := make([]*mast.SwitchCase, len(translated))
	for i, expr := range translated {
		castExpr, ok := expr.(*mast.SwitchCase)
		if !ok {
			return nil, nodeTypeError(expr)
		}
		cases[i] = castExpr
	}

	result.Cases = cases

	return result, nil
}

// expressionCase translates expression_case to mast.SwitchCase.
func (t *GoTranslator) expressionCase(node *ts.Node) (mast.Node, error) {
	// we intentionally share the same logic between expression_case and default case, where default case simply
	// does not have value field.
	// expression_case must have any number of children, so we skip the check here.
	// the organization of children is as follows: value/type (optional), statements (optional, anonymous).

	// get value (for normal switch statement) or type (for type switch statement) field of the case statement.
	var expr *ts.Node
	if expr = node.ChildByField("value"); expr == nil {
		expr = node.ChildByField("type") // may be nil
	}
	statementStartIndex := 0

	result := &mast.SwitchCase{}
	if expr != nil {
		// translate and cast the expr, the expr can be an expression_list which will be translated to multiple
		// mast.Expression nodes grouped by mast.TempGroupNode, so here we set the un-group flag.
		translated, err := translateNodes(t, []*ts.Node{expr}, true /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castValues, err := toExpressions(translated)
		if err != nil {
			return nil, err
		}
		result.Values = castValues
		statementStartIndex++
	}

	// return early if there are no statements attached
	if statementStartIndex == len(node.Children) {
		return result, nil
	}

	// translate and cast the statements
	// The body of the case clause might contain different kinds of statement, including those that might return
	// multiple statements grouped by mast.TempGroupNode. For example, "var x, y int = 1, 2" would be translated to 2
	// mast.VariableDeclaration nodes grouped by mast.TempGroupNode. Therefore here we un-group them.
	translatedStatements, err := translateNodes(t, node.Children[statementStartIndex:], true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	castStatements, err := toStatements(translatedStatements)
	if err != nil {
		return nil, err
	}
	result.Statements = castStatements

	return result, nil
}

// typeSwitchStatement translates type_switch_statement to mast.SwitchStatement.
// It is a specialized type of switch statement in Go where the Value can be a specialized expression (e.g.,
// switch a := b; n := c.(type) {...} ). In this case, we have a specialized expression node
// mast.GoTypeSwitchHeaderExpression to represent the Value, the translation for other parts are the same as
// SwitchStatement.
func (t *GoTranslator) typeSwitchStatement(node *ts.Node) (mast.Node, error) {
	// type_switch_statement must have at least one child: value.
	// initializer (optional), alias (optional), value, list of case expressions (optional, anonymous).
	result := &mast.SwitchStatement{}
	initializer, alias, value := node.ChildByField("initializer"), node.ChildByField("alias"), node.ChildByField("value")
	if value == nil {
		return nil, nilChildError(node)
	}

	// all expression_case nodes following the initializer and value nodes are anonymous, so here we keep track of
	// the start index of the case expressions, which depends on whether initializer / value is present or not.
	caseStartIndex := 0

	header := &mast.GoTypeSwitchHeaderExpression{}

	// translate and cast initializer
	if initializer != nil {
		translatedInitializer, err := t.Translate(initializer)
		if err != nil {
			return nil, err
		}
		castInitializer, ok := translatedInitializer.(mast.Statement)
		if !ok {
			return nil, nodeTypeError(translatedInitializer)
		}
		result.Initializer = castInitializer
		caseStartIndex++
	}

	// translate and cast the alias
	if alias != nil {
		// note that tree-sitter actually generates an expression_list node here, however, Go language specification
		// shows that the alias can only be _an_ identifier.
		// https://golang.org/ref/spec#TypeSwitchStmt
		// so here we unwrap the list of expressions to better conform to language specifications.
		translatedAlias, err := t.Translate(alias)
		if err != nil {
			return nil, err
		}
		group, ok := translatedAlias.(*mast.TempGroupNode)
		if !ok {
			return nil, nodeTypeError(translatedAlias)
		}
		if len(group.Nodes) != 1 {
			return nil, errors.New("alias in type switch statement has more than one element in it")
		}
		castAlias, ok := group.Nodes[0].(*mast.Identifier)
		if !ok {
			return nil, nodeTypeError(group.Nodes[0])
		}

		header.Alias = castAlias
		caseStartIndex++
	}

	// translate and cast the value, note that value must be present.
	translatedValue, err := t.Translate(value)
	if err != nil {
		return nil, err
	}
	castValue, ok := translatedValue.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedValue)
	}

	header.Operand = castValue
	caseStartIndex++

	// now the Value part of SwitchStatement will be the specialized GoTypeSwitchHeaderExpression.
	result.Value = header

	// no case expressions present
	if caseStartIndex == len(node.Children) {
		return result, nil
	}

	// translate and cast case expressions
	translated, err := translateNodes(t, node.Children[caseStartIndex:], false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	cases := make([]*mast.SwitchCase, len(translated))
	for i, expr := range translated {
		castExpr, ok := expr.(*mast.SwitchCase)
		if !ok {
			return nil, nodeTypeError(expr)
		}
		cases[i] = castExpr
	}

	result.Cases = cases

	return result, nil
}

// fieldDeclaration translates field_declaration to mast.FieldDeclaration.
func (t *GoTranslator) fieldDeclaration(node *ts.Node) (mast.Node, error) {
	// field_declaration must have at least 1 child: name (optional), type, tag (optional).
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	names, typeNode, tag := node.ChildrenByField("name"), node.ChildByField("type"), node.ChildByField("tag")
	// type cannot be nil
	if typeNode == nil {
		return nil, nilChildError(typeNode)
	}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}

	// translate and cast names
	var castNames []*mast.Identifier
	if names != nil {
		translatedNames, err := translateNodes(t, names, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		n, err := toIdentifiers(translatedNames)
		if err != nil {
			return nil, err
		}
		castNames = n
	}

	// translate and cast tag
	var castTag *mast.StringLiteral
	if tag != nil {
		translatedTag, err := t.Translate(tag)
		if err != nil {
			return nil, err
		}
		n, ok := translatedTag.(*mast.StringLiteral)
		if !ok {
			return nil, nodeTypeError(translatedTag)
		}
		castTag = n
	}

	if castNames == nil {
		result := &mast.FieldDeclaration{
			Type:       castType,
			LangFields: &mast.GoFieldDeclarationFields{Tag: castTag},
		}
		return result, nil
	}

	result := &mast.TempGroupNode{}
	for _, name := range castNames {
		temp := &mast.FieldDeclaration{
			Name:       name,
			Type:       castType,
			LangFields: &mast.GoFieldDeclarationFields{Tag: castTag},
		}
		result.Nodes = append(result.Nodes, temp)
	}

	return result, nil
}

// structType translates struct_type to mast.GoStructType.
func (t *GoTranslator) structType(node *ts.Node) (mast.Node, error) {
	// struct_type must have 1 child: field_declaration_list.
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	// field_declaration_list will return multiple FieldDeclaration nodes grouped by mast.TempGroupNode, for example,
	// "f1 f2 SomeType `someTag`" will be translated to "f1 SomeType `someTag`" followed by "f2 SomeType `someTag`".
	// Therefore we un-group it here.
	translatedDeclarations, err := translateNodes(t, node.Children, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	declarations := make([]*mast.FieldDeclaration, len(translatedDeclarations))
	for i, child := range translatedDeclarations {
		n, ok := child.(*mast.FieldDeclaration)
		if !ok {
			return nil, nodeTypeError(child)
		}
		declarations[i] = n
	}

	result := &mast.GoStructType{
		Declarations: declarations,
	}

	return result, nil
}

// parameterDeclaration translates parameter_declaration to multiple mast.ParameterDeclaration nodes grouped by
// mast.TempGroupNode or a single mast.ParameterDeclaration. Note that this node is shared by both function parameters
// and return parameters.
func (t *GoTranslator) parameterDeclaration(node *ts.Node) (mast.Node, error) {
	// parameter_declaration must have at least 1 child: multiple name nodes (optional), type.
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	// parameter_declaration could have the following structure:
	// (1) Multiple names with one type (e.g., "a, b int"). We flatten the name list and generate multiple
	//     mast.ParameterDeclaration nodes grouped by mast.TempGroupNode;
	// (2) Single name with one type (e.g., "a int"). We simply translate it and return a mast.ParameterDeclaration node;
	// (3) A bare type (e.g., "int"). We translate it and return a mast.ParameterDeclaration with `Name` field being
	//     nil.
	names, typeNode := node.ChildrenByField("name"), node.ChildByField("type")
	// only names can be nil
	if typeNode == nil {
		return nil, nilChildError(typeNode)
	}

	var castNames []*mast.Identifier
	if names != nil {
		// translate and cast names
		translatedNames, err := translateNodes(t, names, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		n, err := toIdentifiers(translatedNames)
		if err != nil {
			return nil, err
		}
		castNames = n
	}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}

	// early return if only a bare type is given
	if castNames == nil {
		result := &mast.ParameterDeclaration{
			IsVariadic: strings.HasPrefix(node.Type, "variadic"),
			Type:       castType,
		}
		return result, nil
	}

	// otherwise, create multiple ParameterDeclaration nodes based on name list
	result := &mast.TempGroupNode{}
	for _, name := range castNames {
		temp := &mast.ParameterDeclaration{
			IsVariadic: strings.HasPrefix(node.Type, "variadic"),
			Type:       castType,
			Name:       name,
		}
		result.Nodes = append(result.Nodes, temp)
	}

	return result, nil
}

// functionType translates function_type to mast.FunctionType.
func (t *GoTranslator) functionType(node *ts.Node) (mast.Node, error) {
	// function_type must have 1 or 2 children: parameters, result (optional).
	if len(node.Children) < 1 || len(node.Children) > 2 {
		return nil, childrenNumberError(node)
	}

	parameters, returnNode := node.ChildByField("parameters"), node.ChildByField("result")
	// parameters cannot be nil
	if parameters == nil {
		return nil, nilChildError(node)
	}

	// tree-sitter generates an empty parameter_list node even if there are no parameters given, so here we skip the
	// translation if that is the case.
	var castParameters []mast.Declaration
	if len(parameters.Children) != 0 {
		n, err := translateParameters(t, parameters)
		if err != nil {
			return nil, err
		}
		castParameters = n
	}

	var castReturn []mast.Declaration
	if returnNode != nil {
		n, err := translateParameters(t, returnNode)
		if err != nil {
			return nil, err
		}
		castReturn = n
	}

	result := &mast.GoFunctionType{}

	if castParameters != nil {
		result.Parameters = castParameters
	}
	if castReturn != nil {
		result.Return = castReturn
	}

	return result, nil
}

// forStatement translates for_statement to mast.ForStatement.
func (t *GoTranslator) forStatement(node *ts.Node) (mast.Node, error) {
	// for_statement must have 1-2 children: expression/for_clause/range_clause (optional, anonymous), body.
	if len(node.Children) < 1 || len(node.Children) > 2 {
		return nil, childrenNumberError(node)
	}
	var condition, body *ts.Node
	if len(node.Children) == 1 {
		condition, body = nil, node.Children[0]
	} else {
		condition, body = node.Children[0], node.Children[1]
	}

	// for_statement in Go will generate tree structures as follows:
	// for_statement
	//   - for_clause      <- the information is nested inside another level.
	//       - initializer
	//       - condition
	//       - update
	//   - body
	// Similar structure can also be observed for range_clause. Therefore for simplicity of MAST, we try to flatten the
	// tree here. Specifically, translations for for_clause and range_clause will return a partial (without body field)
	// *mast.ForStatement and *mast.GoForRangeStatement, respectively. Then here we fill the body field and return the
	// complete node.

	// first translate and cast body
	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}
	castBody, ok := translatedBody.(*mast.Block)
	if !ok {
		return nil, nodeTypeError(translatedBody)
	}
	// set body to nil if it does not contain any statements for simplicity of MAST
	if len(castBody.Statements) == 0 {
		castBody = nil
	}

	// translate and cast condition
	// The condition could be one of the following cases:
	// (1) expression will be translated to mast.Expression, we then wrap it inside a mast.ForStatement;
	// (2) for_clause/range_clause will be translated to *mast.ForStatement and *mast.GoForRangeStatement, we then fill
	//     in the body field and return the complete node;
	// (3) nil, which means it is a bare for statement "for {...}", we simply return a *mast.ForStatement.
	if condition == nil {
		result := &mast.ForStatement{
			Body: castBody,
		}
		return result, nil
	}

	translatedCondition, err := t.Translate(condition)
	if err != nil {
		return nil, err
	}
	switch n := translatedCondition.(type) {
	case mast.Expression:
		result := &mast.ForStatement{
			Condition: n,
			Body:      castBody,
		}
		return result, nil
	case *mast.ForStatement:
		n.Body = castBody
		return n, nil
	case *mast.GoForRangeStatement:
		n.Body = castBody
		return n, nil
	default:
		return nil, nodeTypeError(translatedCondition)
	}
}

// forClause translates for_clause to a partially-filled mast.ForStatement (Body field is empty and will be filled in
// upper-level during the translations of for_statement).
func (t *GoTranslator) forClause(node *ts.Node) (mast.Node, error) {
	// for_clause can have any number of children so we skip the children number check here.
	// the organization of for_clause is as follows:
	// initializer (optional), condition (optional), update (optional).

	initializer, condition, update := node.ChildByField("initializer"), node.ChildByField("condition"), node.ChildByField("update")

	// We intentionally leave Body blank which will be filled in upper-level (during the translations of for_statement).
	result := &mast.ForStatement{}

	// translate and cast condition
	if condition != nil {
		translatedCondition, err := t.Translate(condition)
		if err != nil {
			return nil, err
		}
		cast, ok := translatedCondition.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedCondition)
		}
		result.Condition = cast
	}

	// translate and cast initializer and update
	translatedStatements, err := translateNodes(t, []*ts.Node{initializer, update}, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	// The initializer/update could be translated to mast.AssignmentExpression nodes, here calling toStatements helper
	// function will also wrap it inside a proper statement wrapper (mast.ExpressionStatement).
	castStatements, err := toStatements(translatedStatements)
	if err != nil {
		return nil, err
	}

	// Go only allows one statement in initializer/update.
	if castStatements[0] != nil {
		result.Initializers = []mast.Statement{castStatements[0]}
	}
	if castStatements[1] != nil {
		result.Updates = []mast.Statement{castStatements[1]}
	}

	return result, nil
}

// rangeClause translates range_clause to mast.GoForRangeStatement.
func (t *GoTranslator) rangeClause(node *ts.Node) (mast.Node, error) {
	// range_clause must have at least 2 children: left (optional), operator (optional, anonymous), "range", right.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	left, right := node.ChildByField("left"), node.ChildByField("right")

	// translate and cast iterable
	translatedRight, err := t.Translate(right)
	if err != nil {
		return nil, err
	}
	castRight, ok := translatedRight.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedRight)
	}

	// Now we construct the mast.GoForRangeStatement.
	result := &mast.GoForRangeStatement{
		// Body will be intentionally left blank to be filled by upper-level (during the translations of for_statement).
	}

	// If there is no LHS, we leave the Assignment field nil.
	if left == nil {
		// put the right expression to the Iterable Field
		result.Iterable = castRight
		return result, nil
	}

	// Otherwise, we create an assignment node.

	// The range clause behaves very similar to an (imbalanced) assignment expression which is part of
	// mast.GoForRangeStatement. So we first construct the mast.AssignmentExpression node.
	result.Assignment = &mast.AssignmentExpression{
		Right: []mast.Expression{castRight},
	}

	// Since right must exists, we can retrieve the optional and anonymous operator by (trying) accessing the third
	// to last element.
	if len(node.Children) > 3 {
		operator := node.Children[len(node.Children)-3]
		// The operator is also optional (e.g., "for range lst {...}"), so here we only set the flag if the operator
		// exists and is ":=".
		if operator.Type == mast.AssignmentEqualOperator || operator.Type == mast.AssignmentDeclareOperator {
			result.Assignment.IsShortVarDeclaration = (operator.Type == mast.AssignmentDeclareOperator)
		}
	}

	// here left is an expression_list node containing multiple expressions grouped by mast.TempGroupNode, therefore
	// here we un-group them.
	translatedLeft, err := translateNodes(t, []*ts.Node{left}, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	castLeft, err := toExpressions(translatedLeft)
	if err != nil {
		return nil, err
	}
	result.Assignment.Left = castLeft

	return result, nil
}

// element translates element to mast.Expression. This node only appears in literal_value and is a wrapper node for
// either an expression or another literal_value. For example:
//
//	Test{
//	  a,       <- element node with an identifier child
//	  b,       <- element node with an identifier child
//	  Test2{   <- element node with another literal_value child
//	    A: a,    <- keyed_element node
//	    B: b,    <- keyed_element node
//	  }
//	}
//
// keyed_element node functions like key-value pair and its translation is _not_ handled by this method.
func (t *GoTranslator) element(node *ts.Node) (mast.Node, error) {
	// element must have 1 child: expression/literal_value (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	// Here we simply unwrap the element node and directly return the translated inner node, the upper-level
	// (literal_value) will simply put the node in its element slice. So for simplicity, there is no need to wrap it
	// inside a "element" node.

	// translate and cast value
	translatedValue, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	castValue, ok := translatedValue.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedValue)
	}

	return castValue, nil
}

// compositeLiteral translates composite_literal to mast.EntityCreationExpression.
func (t *GoTranslator) compositeLiteral(node *ts.Node) (mast.Node, error) {
	// composite_literal must have 2 children: type, body.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	typeNode, body := node.Children[0], node.Children[1]

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}

	// translate and cast body
	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}
	castBody, ok := translatedBody.(*mast.LiteralValue)
	if !ok {
		return nil, nodeTypeError(translatedBody)
	}

	result := &mast.EntityCreationExpression{
		Type:  castType,
		Value: castBody,
	}
	return result, nil
}

// selectStatement translates select_statement to mast.SelectStatement.
func (t *GoTranslator) selectStatement(node *ts.Node) (mast.Node, error) {
	// select_statement can have any number of children so we skip the check here.
	// The children contain a slice of communication_case or default_case nodes, so we simply translate all the children
	// and create a mast.GoSelectStatement.
	// Note that select_statement and expression_switch_statement share the same "default_case" node in their children,
	// so the translation of default_case will return a mast.SwitchCase. To fix this, if a default_case is present,
	// we unwrap its Body field and re-wrap it inside a mast.CommunicationCase node instead.

	result := &mast.GoSelectStatement{}

	// early return if no cases are present
	if len(node.Children) == 0 {
		return result, nil
	}

	// translate and cast communication cases, including converting default mast.SwitchCase to mast.GoCommunicationCase
	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	cases := make([]*mast.GoCommunicationCase, len(translated))
	for i, child := range translated {
		switch n := child.(type) {
		case *mast.GoCommunicationCase:
			cases[i] = n
		case *mast.SwitchCase:
			// It must be a default case, i.e., Values is nil.
			if n.Values != nil {
				return nil, errors.New("unexpected non-default switch case in select statement")
			}
			temp := &mast.GoCommunicationCase{
				Statements: n.Statements,
			}
			cases[i] = temp
		default:
			return nil, nodeTypeError(child)
		}
	}
	result.Cases = cases

	return result, nil
}

// communicationCase translates communication_case to mast.GoCommunicationCase.
func (t *GoTranslator) communicationCase(node *ts.Node) (mast.Node, error) {
	// communication_case must have at least 1 child: communication, list of statements (anonymous)
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	// The statement in the statement list could be translated to multiple MAST statement nodes grouped by
	// mast.TempGroupNode, such as "var x, y int = 1, 2". Therefore here we un-group them.
	translated, err := translateNodes(t, node.Children, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	cast, err := toStatements(translated)
	if err != nil {
		return nil, err
	}
	communication, statements := cast[0], cast[1:]

	result := &mast.GoCommunicationCase{
		Communication: communication,
	}
	if len(statements) > 0 {
		result.Statements = statements
	}

	return result, nil
}

// receiveStatement translates receive_statement to one of the following cases:
// (1) "case a, b = c" or "case a, b := c": mast.AssignmentExpression wrapped inside mast.ExpressionStatement;
// (2) "case a": mast.Expression wrapped inside mast.ExpressionStatement.
// The receive_statement only appears in Go's communication_case and it is one of the choices (send_statement,
// receive_statement) for the case condition.
func (t *GoTranslator) receiveStatement(node *ts.Node) (mast.Node, error) {
	// receiver_statement must have 1 or 3 children: left (optional), operator (optional, anonymous), right.
	if len(node.Children) != 1 && len(node.Children) != 3 {
		return nil, childrenNumberError(node)
	}

	var left, right *ts.Node
	var operator string
	if len(node.Children) == 1 {
		right = node.Children[0]
	} else {
		left, operator, right = node.Children[0], node.Children[1].Type, node.Children[2]
	}

	// translate and cast left
	var castLeft []mast.Expression
	if left != nil {
		// left is an expression_list node which would be translated to multiple mast.Expression nodes grouped by
		// mast.TempGroupNode, therefore we un-group them here.
		// For example, "a, b" in "a, b = c" would be translated to two identifier nodes ("a" and "b").
		translatedLeft, err := translateNodes(t, []*ts.Node{left}, true /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		n, err := toExpressions(translatedLeft)
		if err != nil {
			return nil, err
		}
		castLeft = n
	}

	// translate and cast right
	translatedRight, err := t.Translate(right)
	if err != nil {
		return nil, err
	}
	castRight, ok := translatedRight.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedRight)
	}

	// return a mast.AssignmentExpression wrapped inside a mast.ExpressionStatement
	switch operator {
	case "":
		result := &mast.ExpressionStatement{
			Expr: castRight,
		}
		return result, nil
	case mast.AssignmentEqualOperator, mast.AssignmentDeclareOperator:
		isShortVarDeclaration := (operator == mast.AssignmentDeclareOperator)
		// if operator exists, left must exist
		result := &mast.ExpressionStatement{
			Expr: &mast.AssignmentExpression{
				IsShortVarDeclaration: isShortVarDeclaration,
				Left:                  castLeft,
				Right:                 []mast.Expression{castRight},
			},
		}
		return result, nil
	default:
		return nil, fmt.Errorf("invalid operator %q in receive_statement", operator)
	}
}

// funcLiteral translates func_literal to mast.FunctionLiteral.
func (t *GoTranslator) funcLiteral(node *ts.Node) (mast.Node, error) {
	// func_literal must have 2 or 3 children: parameters, result (optional), body.
	if len(node.Children) != 2 && len(node.Children) != 3 {
		return nil, childrenNumberError(node)
	}

	result := &mast.FunctionLiteral{}

	parameters, returnNode, body := node.ChildByField("parameters"), node.ChildByField("result"), node.ChildByField("body")
	// only result is optional
	if parameters == nil || body == nil {
		return nil, nilChildError(node)
	}

	// translate and cast parameters
	castParameters, err := translateParameters(t, parameters)
	if err != nil {
		return nil, err
	}
	result.Parameters = castParameters

	// translate and cast body
	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}
	castBody, ok := translatedBody.(*mast.Block)
	if !ok {
		return nil, nodeTypeError(translatedBody)
	}
	result.Statements = castBody.Statements

	// early return if return type is empty
	if returnNode == nil {
		return result, nil
	}

	// translate and cast returns
	castReturns, err := translateParameters(t, returnNode)
	if err != nil {
		return nil, err
	}
	result.Returns = castReturns

	return result, nil
}

// functionDeclaration translates function_declaration and method_declaration to mast.FunctionDeclaration.
// function_declaration is a special case of method_declaration which lacks receiver field, hence we share the same
// translation methods here.
func (t *GoTranslator) functionDeclaration(node *ts.Node) (mast.Node, error) {
	// method_declaration/function_declaration must have at least 2 children:
	// receiver (optional), name, parameters, result (optional), body (optional).
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	receiver, name := node.ChildByField("receiver"), node.ChildByField("name")
	parameters, returnNode := node.ChildByField("parameters"), node.ChildByField("result")
	body := node.ChildByField("body")
	// name and parameters must exist
	if name == nil || parameters == nil {
		return nil, nilChildError(node)
	}

	// put the pointer of the extra node on the result here so that later edits of the extra node will automatically be
	// reflected on the result.
	extra := &mast.GoFunctionDeclarationFields{}
	result := &mast.FunctionDeclaration{LangFields: extra}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	// tree-sitter generates an empty parameter_list node even if there are no parameters given, so here we skip the
	// translation if that is the case.
	if len(parameters.Children) != 0 {
		// parameters is a parameter_list node, therefore here we simply unwrap it. Moreover, each element _might_
		// return a mast.TempGroupNode due to "a, b int" being translated to "a int, b int", so we un-group them here.
		castParameters, err := translateParameters(t, parameters)
		if err != nil {
			return nil, err
		}
		result.Parameters = castParameters
	}

	if returnNode != nil {
		// Here we do the same as parameters.
		castReturns, err := translateParameters(t, returnNode)
		if err != nil {
			return nil, err
		}
		result.Returns = castReturns
	}

	if body != nil {
		// translate and cast body
		translatedBody, err := t.Translate(body)
		if err != nil {
			return nil, err
		}
		castBody, ok := translatedBody.(*mast.Block)
		if !ok {
			return nil, nodeTypeError(translatedBody)
		}
		result.Statements = castBody.Statements
	}

	// If no receiver is given, it means that this node is a function declaration and we can directly return
	// the function declaration node.
	if receiver == nil {
		castName.Kind = mast.Function
		return result, nil
	}

	// it would be more natural castName's kind set where castName is
	// defined, but we have to wait until receiver is set (or not)
	castName.Kind = mast.Method

	// Otherwise, add the receiver field to the result node.

	// According to Golang's specification [1], the receiver can only be one single non-variadic parameter.
	// [1] https://golang.org/ref/spec#Receiver
	castParameters, err := translateParameters(t, receiver)
	if err != nil {
		return nil, err
	}
	if len(castParameters) != 1 {
		return nil, errors.New("more than one receiver in method declaration")
	}
	extra.Receiver = castParameters[0]

	return result, nil
}

// interfaceType translates interface_type to mast.GoInterfaceType.
func (t *GoTranslator) interfaceType(node *ts.Node) (mast.Node, error) {
	// interface_type must have 1 child: method_spec_list.
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	// We simply unwrap the method_spec_list and translate all its children to one of the following:
	// (1) mast.FunctionDeclaration with empty Body for empty method specifications;
	// (2) mast.Expression for interface embeddings.
	declarations, err := translateNodes(t, node.Children[0].Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	result := &mast.GoInterfaceType{}
	// Here we wrap the interface embeddings around a mast.FieldDeclaration node.
	for _, child := range declarations {
		switch n := child.(type) {
		case *mast.FunctionDeclaration:
			result.Declarations = append(result.Declarations, n)
		case mast.Expression:
			temp := &mast.FieldDeclaration{
				Type:       n,
				LangFields: &mast.GoFieldDeclarationFields{},
			}
			result.Declarations = append(result.Declarations, temp)
		default:
			return nil, nodeTypeError(child)
		}
	}

	return result, nil
}

// typeConversionExpression translates type_conversion_expression to mast.CastExpression.
func (t *GoTranslator) typeConversionExpression(node *ts.Node) (mast.Node, error) {
	// type_conversion_expression must have 2 children: type, operand.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	cast, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	// CastExpression allows specifying multiple types for compatibility with other languages, however, in Go there can
	// only be one type for conversion. Therefore we wrap type in a slice.
	result := &mast.CastExpression{
		Types:   []mast.Expression{cast[0]},
		Operand: cast[1],
	}

	return result, nil
}

// incDecStatement translates inc_statement and dec_statement to mast.UpdateExpression wrapped in
// mast.ExpressionStatement.
func (t *GoTranslator) incDecStatement(node *ts.Node) (mast.Node, error) {
	// inc_statement and dec_statement in Go are just more restrictive cases of update_expression where the
	// operator can only be placed after the expression. So here we first translate it as update_expression, and then
	// wrap it in mast.ExpressionStatement.
	node.Type = "update_expression"

	update, err := t.Translate(node)
	if err != nil {
		return nil, err
	}

	castUpdate, ok := update.(*mast.UpdateExpression)
	if !ok {
		return nil, nodeTypeError(update)
	}

	result := &mast.ExpressionStatement{Expr: castUpdate}
	return result, nil
}
