//  Copyright (c) 2023 Uber Technologies, Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package translation

import (
	"errors"
	"fmt"

	"analyzer/core/mast"
	"analyzer/core/mast/mastutil"
	ts "analyzer/core/treesitter"
)

// JavaTranslator translates Java AST generated by tree-sitter to MAST AST.
type JavaTranslator struct{}

// Translate handles special cases for Java AST, other node types are handled by GenericTranslator.
// The full documentation of the Java AST can be found at
// https://github.com/tree-sitter/tree-sitter-java/blob/master/src/node-types.json and
// https://github.com/tree-sitter/tree-sitter-java/blob/master/src/grammar.json
func (t *JavaTranslator) Translate(node *ts.Node) (mast.Node, error) {
	// the translations of some nodes can be shared across different languages, where the only difference is the name
	// for node.Type. Therefore, we first handle name rewrites here.
	switch node.Type {
	case "program":
		node.Type = "root"
	case "super", "this", "void_type", "boolean_type", "floating_point_type", "integral_type", "asterisk":
		// the nodes above are just special identifiers in Java AST.
		node.Type = "identifier"
	case "decimal_integer_literal", "hex_integer_literal", "octal_integer_literal", "binary_integer_literal":
		// we store the int literal in strings, so the translations for different int literals can share the same logic.
		node.Type = "int_literal"
	case "decimal_floating_point_literal", "hex_floating_point_literal":
		// we store the float literal in strings, so the translations for hexadecimal and decimal float literals
		// can share the same logic.
		node.Type = "float_literal"
	case "array_access":
		// array access in Java AST is the same as index expression, so we rename the type for it to be handled by
		// generic translator.
		node.Type = "index_expression"
	case "marker_annotation":
		// marker_annotation in Java is just a simple case for annotation without arguments.
		node.Type = "annotation"
	case "annotation_argument_list", "argument_list", "type_arguments", "formal_parameters", "type_parameters",
		"interface_type_list", "catch_type", "type_bound", "module_body", "enum_body_declarations",
		"resource_specification":
		// The node types above share the same logics as list: simply translate all children and return a TempGroupNode.
		// More specifically:
		// (1) *_list and plural nodes are simply a list of nodes with the same type;
		// (2) catch_type contains a list of types that are connected by "|" (e.g., "catch (A|B ex)");
		// (3) type_bound contains a list of types that are connected by "&" (e.g., "class A<B extends C & D>");
		// (4) *_body nodes contain a list of statements or declarations.
		// (5) enum_body_declarations is the same as class_body but with a ";" terminal before all the children (which
		//     is dropped in tree-sitter already).
		// (6) resource_specification node is a wrapper node that wraps around multiple resource nodes.
		node.Type = "list"
	case "switch_block", "constructor_body":
		// switch_block is the same as normal block, except they are inside switch statements.
		// constructor_body is the same as normal block, except they allow explicit_constructor_invocation node to be
		// inside them.
		node.Type = "block"
	case "element_value_pair":
		// element_value_pair is just a regular key_value_pair.
		node.Type = "key_value_pair"
	case "element_value_array_initializer", "array_initializer":
		// element_value_array_initializer (e.g., "(a=1, b=2, c={1,2,3})") can be handled by our more general
		// representation "literal_value".
		node.Type = "literal_value"
	case "constructor_declaration":
		// constructor_declaration is a special case for method_declaration where the type field is optional.
		node.Type = "method_declaration"
	case "try_with_resources_statement":
		// try_with_resources_statement is the same as try_statement but with an optional resources field.
		node.Type = "try_statement"
	}

	// here we delegate the translation to unexported methods.
	switch node.Type {
	case "field_access":
		return t.fieldAccess(node)
	case "type_identifier":
		return t.typeIdentifier(node)
	case "package_declaration":
		return t.packageDeclaration(node)
	case "import_declaration":
		return t.importDeclaration(node)
	case "expression_statement":
		return t.expressionStatement(node)
	case "while_statement":
		return t.whileStatement(node)
	case "scoped_identifier":
		return t.scopedIdentifier(node)
	case "ternary_expression":
		return t.ternaryExpression(node)
	case "cast_expression":
		return t.castExpression(node)
	case "method_invocation":
		return t.methodInvocation(node)
	case "annotation":
		return t.annotation(node)
	case "annotated_type":
		return t.annotatedType(node)
	case "wildcard":
		return t.wildcard(node)
	case "generic_type":
		return t.genericType(node)
	case "dimensions":
		return t.dimensions(node)
	case "dimensions_expr":
		return t.dimensionsExpr(node)
	case "array_type":
		return t.arrayType(node)
	case "instanceof_expression":
		return t.instanceofExpression(node)
	case "switch_statement":
		return t.switchStatement(node)
	case "switch_label":
		return t.switchLabel(node)
	case "throw_statement":
		return t.throwStatement(node)
	case "assert_statement":
		return t.assertStatement(node)
	case "synchronized_statement":
		return t.synchronizedStatement(node)
	case "do_statement":
		return t.doStatement(node)
	case "try_statement":
		return t.tryStatement(node)
	case "catch_formal_parameter":
		return t.catchFormalParameter(node)
	case "catch_clause":
		return t.catchClause(node)
	case "finally_clause":
		return t.finallyClause(node)
	case "modifiers":
		return t.modifiers(node)
	case "formal_parameter", "spread_parameter":
		// spread_parameter is just a special case of formal_parameter with a slight difference in children structure
		// see formalParameter for detailed explanation.
		return t.formalParameter(node)
	case "inferred_parameters":
		return t.inferredParameters(node)
	case "receiver_parameter":
		return t.receiverParameter(node)
	case "variable_declarator":
		return t.variableDeclarator(node)
	case "lambda_expression":
		return t.lambdaExpression(node)
	case "local_variable_declaration":
		return t.localVariableDeclaration(node)
	case "for_statement":
		return t.forStatement(node)
	case "enhanced_for_statement":
		return t.enhancedForStatement(node)
	case "array_creation_expression":
		return t.arrayCreationExpression(node)
	case "object_creation_expression":
		return t.objectCreationExpression(node)
	case "requires_modifier":
		return t.requiresModifier(node)
	case "module_directive":
		return t.moduleDirective(node)
	case "module_declaration":
		return t.moduleDeclaration(node)
	case "type_parameter":
		return t.typeParameter(node)
	case "superclass":
		return t.superclass(node)
	case "super_interfaces":
		return t.superInterfaces(node)
	case "field_declaration":
		return t.fieldDeclaration(node, false)
	case "constant_declaration":
		// constant_declaration is the same as field_declaration,
		// except that constant_declaration nodes only appear in
		// interface_declaration.
		return t.fieldDeclaration(node, true)
	case "class_declaration":
		return t.classDeclaration(node)
	case "static_initializer":
		return t.staticInitializer(node)
	case "method_declaration":
		return t.methodDeclaration(node)
	case "interface_declaration":
		return t.interfaceDeclaration(node)
	case "explicit_constructor_invocation":
		return t.explicitConstructorInvocation(node)
	case "enum_declaration":
		return t.enumDeclaration(node)
	case "enum_constant":
		return t.enumConstant(node)
	case "annotation_type_declaration":
		return t.annotationTypeDeclaration(node)
	case "annotation_type_element_declaration":
		return t.annotationTypeElementDeclaration(node)
	case "resource":
		return t.resource(node)
	case "method_reference":
		return t.methodReference(node)
	case "class_literal":
		return t.classLiteral(node)
	case "scoped_type_identifier":
		return t.scopedTypeIdentifier(node)
	// fallback to generic translation
	default:
		return (&GenericTranslator{Lang: t}).Translate(node)
	}
}

/* a few helper functions */

// translateModifiers is a helper function that translates and casts the modifiers node to a slice of
// *mast.JavaLiteralModifier or *mast.Annotation nodes.
func translateModifiers(t Translator, modifiers *ts.Node) ([]mast.Expression, error) {
	// modifiers node could contain a list of modifier nodes, which is translated to mast.TempGroupNode. Therefore
	// here we un-group the node.
	translatedModifiers, err := translateNodes(t, []*ts.Node{modifiers}, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	// a modifier node could either be translated to JavaLiteralModifiers node or Annotation node,
	// therefore we cast them to Expression nodes instead.
	castModifiers, err := toExpressions(translatedModifiers)
	if err != nil {
		return nil, err
	}
	return castModifiers, nil
}

// translateDimensions is a helper function that translates and casts the dimensions node to a slice of
// *mast.JavaDimension nodes.
func translateDimensions(t Translator, dimensions *ts.Node) ([]*mast.JavaDimension, error) {
	translatedDimensions, err := t.Translate(dimensions)
	if err != nil {
		return nil, err
	}
	// dimensions node should be translated to mast.TempGroupNode since it may contain multiple dimensions.
	group, ok := translatedDimensions.(*mast.TempGroupNode)
	if !ok {
		return nil, nodeTypeError(translatedDimensions)
	}
	// properly cast each element to mast.JavaDimension
	castDimensions := make([]*mast.JavaDimension, len(group.Nodes))
	for i, child := range group.Nodes {
		n, ok := child.(*mast.JavaDimension)
		if !ok {
			return nil, nodeTypeError(child)
		}
		castDimensions[i] = n
	}
	return castDimensions, nil
}

// translateTypeParameters is a helper function that translates and
// casts the type_parameters node (representing types in generic type
// declarations, optionally with wildcards etc.) to a slice of
// *mast.JavaTypeParameter nodes.
func translateTypeParameters(t Translator, typeParameters *ts.Node) ([]*mast.JavaTypeParameter, error) {
	// type_parameters will be translated to multiple mast.JavaTypeParameter nodes grouped by mast.TempGroupNode (
	// e.g., "class Test<A, B, C>"). Therefore here we un-group them.
	cast := make([]*mast.JavaTypeParameter, len(typeParameters.Children))
	translated, err := translateNodes(t, []*ts.Node{typeParameters}, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	for i, child := range translated {
		n, ok := child.(*mast.JavaTypeParameter)
		if !ok {
			return nil, nodeTypeError(child)
		}
		cast[i] = n
	}
	return cast, nil
}

// translateAnnotations is a helper function that translates and casts a slice of *_annotation node to a slice of
// *mast.Annotation nodes.
func translateAnnotations(t Translator, annotations []*ts.Node) ([]*mast.Annotation, error) {
	translated, err := translateNodes(t, annotations, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	cast := make([]*mast.Annotation, len(translated))
	for i, annotation := range translated {
		a, ok := annotation.(*mast.Annotation)
		if !ok {
			return nil, nodeTypeError(annotation)
		}
		cast[i] = a
	}
	return cast, nil
}

// translateVariableDeclaration is a helper function that properly translates and generates a *mast.VariableDeclaration
// node based on the input parameters. Note that name and typeNode must be non-nil.
func translateVariableDeclaration(t Translator, modifiers *ts.Node, typeNode *ts.Node, name *ts.Node, dimensions *ts.Node, value *ts.Node) (*mast.VariableDeclaration, error) {
	if typeNode == nil || name == nil {
		return nil, errors.New("unexpected nil node for name/type in variable decalration translation")
	}

	result := &mast.VariableDeclaration{}

	var err error
	var translatedModifiers []mast.Expression
	// translate and cast modifiers
	if modifiers != nil {
		// modifiers node contains a list of modifier nodes, so we un-group them here.
		translatedModifiers, err = translateModifiers(t, modifiers)
		if err != nil {
			return nil, err
		}
		result.IsConst = mastutil.HasJavaModifier(translatedModifiers, mast.FinalMod)
	}

	// Local variables are private so mark them as such with a
	// modifier - we need this to do renaming properly and we dont't
	// care it does not quite reflect Java syntax.

	// The only other modifier possibly present here is the "final"
	// one (as per
	// https://docs.oracle.com/javase/specs/jls/se11/html/jls-14.html#jls-14.4.1)
	// so we can simply append the "private" modifier here.
	translatedModifiers = append(translatedModifiers, &mast.JavaLiteralModifier{Modifier: mast.PrivateMod})

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	// just a reminder - expressions in a variable declaration are
	// type identifiers (e.g., Clazz in Clazz tmp;) or scoped type
	// identifiers (e.g., Foo.Clazz Foo.Clazz tmp;) and are handled
	// when these identifers are translated
	result.Type = castType

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Names = []*mast.Identifier{castName}

	var translatedDimensions []*mast.JavaDimension
	if dimensions != nil {
		translatedDimensions, err = translateDimensions(t, dimensions)
		if err != nil {
			return nil, err
		}
	}

	if translatedModifiers != nil || translatedDimensions != nil {
		extra := &mast.JavaVariableDeclarationFields{
			Modifiers:  translatedModifiers,
			Dimensions: translatedDimensions,
		}
		result.LangFields = extra
	}

	// translate and cast value
	if value != nil {
		translatedValue, err := t.Translate(value)
		if err != nil {
			return nil, err
		}
		castValue, ok := translatedValue.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedValue)
		}
		result.Value = castValue
	}

	return result, nil
}

// translateClassBody translates class_body to a slice of declarations inside the class_body, which will be consumed
// later to form other MAST nodes. It properly handles the initializer blocks in the body and wraps them inside
// mast.JavaClassInitializer nodes.
func translateClassBody(t Translator, classBody *ts.Node) ([]mast.Declaration, error) {
	// class_body contains multiple declaration nodes, some of them could be translated to multiple declaration
	// nodes grouped by mast.TempGroupNode (e.g., field declaration "private int a, b;" ->
	// "private int a; private int b;"). Therefore here we un-group them.
	translatedBody, err := translateNodes(t, classBody.Children, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	// There are two cases for the initializers in the class body:
	// (1) static initializers: tree-sitter will generate a static_initializer node with a block node inside it. This
	//     will be translated to mast.JavaClassInitializer node;
	// (2) normal initializer: tree-sitter will simply generate a block node and it will be translated to a mast.Block
	//     node. Therefore here we should wrap it inside a mast.JavaClassInitializer node.
	castBody := make([]mast.Declaration, len(translatedBody))
	for i, decl := range translatedBody {
		switch n := decl.(type) {
		// For the initializer nodes, we wrap it in a mast.JavaClassInitializer node (which is a mast.Declaration node).
		case *mast.Block:
			castBody[i] = &mast.JavaClassInitializer{Block: n}
		// The other nodes in the class body, such as field, method, inner classes etc, are all mast.Declaration nodes.
		// Therefore we directly append the declaration node to the result.
		case mast.Declaration:
			castBody[i] = n
		default:
			return nil, fmt.Errorf("unexpected node type %T in class body", decl)
		}
	}

	return castBody, nil
}

// fieldAccess translates field_access to mast.AccessPath.
func (t *JavaTranslator) fieldAccess(node *ts.Node) (mast.Node, error) {
	if len(node.Children) == 2 {
		node.Type = "access_path"
		return (&GenericTranslator{Lang: t}).Translate(node)
	}
	// This field access contains the "super" keyword which is handled
	// differently than, for example the "this" keyword even though
	// syntactically these field accesses look the same (e.g.,
	// a.super.bar and a.this.bar). The "this" keyword is a regular
	// identifier in field access whereas the "super" keyword is a
	// separate child node.
	if node.Children[1].Name != "super" {
		return nil, errors.New("second (out of 3) child of \"field_access\" node is not \"super\" keyword")
	}

	// Conceptually, this field access has three components, so we'd
	// translate it into two (recursive) field accesses for
	// consistency with how the "this" keyword is handled.
	prefix := ts.Node{
		Type:     "access_path",
		Children: []*ts.Node{node.Children[0], node.Children[1]},
	}
	accessPath := ts.Node{
		Type:     "access_path",
		Children: []*ts.Node{&prefix, node.Children[2]},
	}

	return (&GenericTranslator{Lang: t}).Translate(&accessPath)
}

// typeIdentifier translates type_identifier to mast.Identifier.
func (t *JavaTranslator) typeIdentifier(node *ts.Node) (mast.Node, error) {
	result := &mast.Identifier{
		Name: node.Name,
		Kind: mast.Typ,
	}
	return result, nil
}

// packageDeclaration translates package_declaration to mast.PackageDeclaration.
func (t *JavaTranslator) packageDeclaration(node *ts.Node) (mast.Node, error) {
	// package_declaration can have 1 or 2 children: annotation (optional, anonymous), name (anonymous).
	if len(node.Children) != 1 && len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	var annotation, name *ts.Node
	if len(node.Children) == 1 {
		annotation, name = nil, node.Children[0]
	} else {
		annotation, name = node.Children[0], node.Children[1]
	}

	result := &mast.PackageDeclaration{}

	// translate and cast annotation
	if annotation != nil {
		translatedAnnotation, err := t.Translate(annotation)
		if err != nil {
			return nil, err
		}
		castAnnotation, ok := translatedAnnotation.(*mast.Annotation)
		if !ok {
			return nil, nodeTypeError(translatedAnnotation)
		}
		result.Annotation = castAnnotation
	}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	return result, nil
}

// import_declaration has the following structure:
// (1) scoped import, e.g., "import java.lang.System;" or "import java.lang.*;"
//
//	import_declaration:
//	  scoped_identifier:
//	    scoped_identifier:
//	      identifier: java
//	      identifier: lang
//	    asterisk or identifier: System
//
// (2) single import, e.g., "import java;"
//
//	import_declaration:
//	  identifier
//
// in either case, the scoped_identifier will be flattened into a single mast.Identifier node where Name is set to
// the entire import path, e.g., "java.lang.System".
func (t *JavaTranslator) importDeclaration(node *ts.Node) (mast.Node, error) {
	// import_declaration can have up to two children (all are anonymous nodes):
	// with asterisk (e.g., import java.*;): (scoped_identifier / identifier, asterisk)
	// without asterisk (e.g., import java.lang.System;): (scoped_identifier)
	// single import (e.g., import java;): (identifier)
	if len(node.Children) != 1 && len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	var (
		path              = node.Children[0]
		asterisk *ts.Node = nil
	)
	if len(node.Children) == 2 {
		asterisk = node.Children[1]
	}

	// translate and cast path
	translatedPath, err := t.Translate(path)
	if err != nil {
		return nil, err
	}
	castPath, ok := translatedPath.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedPath)
	}

	// append asterisk to path if present
	if asterisk != nil {
		translatedAsterisk, err := t.Translate(asterisk)
		if err != nil {
			return nil, err
		}
		castAsterisk, ok := translatedAsterisk.(*mast.Identifier)
		if !ok {
			return nil, nodeTypeError(translatedPath)
		}
		castPath = &mast.AccessPath{
			Operand: castPath,
			Field:   castAsterisk,
		}
	}

	result := &mast.ImportDeclaration{
		Package: castPath,
	}

	return result, nil
}

// castExpression translates cast_expression to mast.JavaCastExpression.
func (t *JavaTranslator) castExpression(node *ts.Node) (mast.Node, error) {
	// cast_expression must have at least 2 children: multiple types, value.
	// Java allows specifying multiple types for the cast expression (e.g., "(T1 & T2 ...)expr"), therefore there could
	// potentially be multiple type nodes and one single value node.
	// See https://docs.oracle.com/javase/specs/jls/se11/html/jls-15.html#jls-15.16 for a detailed explanation.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	// We translate all children at once, the last one must be the value field and the remaining nodes are the types.
	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}
	// just a reminder - type expressions in a cast expression are
	// type identifiers (e.g., Clazz in (Clazz)obj) or scoped type
	// identifiers (e.g., Foo.Clazz in (Foo.Clazz)obj) and are handled
	// when these identifers are translated

	result := &mast.CastExpression{
		Types:   expressions[:len(expressions)-1],
		Operand: expressions[len(expressions)-1],
	}

	return result, nil
}

// expressionStatement translates expression_statement to mast.ExpressionStatement.
func (t *JavaTranslator) expressionStatement(node *ts.Node) (mast.Node, error) {
	// expression_statement must have one child: expression (anonymous)
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	expression, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.ExpressionStatement{
		Expr: expression,
	}
	return result, nil
}

// methodInvocation translates method_invocation to mast.CallExpression with
// extra mast.JavaCallExpressionFields for the optional type arguments.
func (t *JavaTranslator) methodInvocation(node *ts.Node) (mast.Node, error) {
	// method_invocation has 2-% children: object (optional), name,
	// arguments, and (both optional) type arguments as well as
	// "super" keywords which we translate separately (see comments
	// below)
	nodes := []*ts.Node{
		node.ChildByField("object"),
		node.ChildByField("name"),
		node.ChildByField("arguments"),
	}
	typeArguments := node.ChildByField("type_arguments")

	// only the object can be nil, others cannot.
	for i := 1; i < len(nodes); i++ {
		if nodes[i] == nil {
			return nil, nilChildError(node)
		}
	}

	// method_invocation node structure generated by tree-sitter is slightly different from our mast.CallExpression.
	// For example, "foo.bar(a,b)" will give us the following structure:
	// method_invocation:
	// |--object: Identifier: "foo"
	// |--name: Identifier: "bar"
	// |--argument_list: .....
	// where the method name "bar" is splitted from the preceding object name. However, the Operand field in our
	// mast.CallExpression should be a mast.SelectorExpression that wraps the entire method name (i.e., "foo.bar" in
	// this case), so here we t the format for better unification.
	translated, err := translateNodes(t, nodes, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	// the expression for method name
	name, ok := expressions[1].(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(expressions[1])
	}
	name.Kind = mast.Method

	// If object field is not nil, wrap the name within mast.AccessPath.
	var methodSelector mast.Expression
	if expressions[0] != nil {

		// Method invocation's access path can also contain a keyword:
		// "this" or "super", for example in a.this.bar() or
		// a.super.bar().
		//
		// While "this" is treated as regular identifier, "super" is a
		// separate child node placed right after the "object" child
		// (that is in the second position). Interestingly, if "super"
		// is in the first position of the access path, such as in
		// super.bar(), it becomes the "object" child and not
		// additional "super" child node is present.

		// if the additional "super" child exists, make it part of the
		// access path for consistency with how the "this" keyword is
		// handled
		var prefix mast.Expression
		if node.Children[1].Name == "super" {
			prefix = &mast.AccessPath{
				Operand: expressions[0],
				Field:   &mast.Identifier{Name: "super"},
			}
		} else {
			prefix = expressions[0]
		}

		methodSelector = &mast.AccessPath{
			Operand: prefix,
			Field:   name,
		}
	} else {
		methodSelector = name
	}

	// first three expressions are object, and name, the rest are arguments.
	var arguments []mast.Expression
	if len(expressions) > 2 {
		arguments = expressions[2:]
	}

	result := &mast.CallExpression{
		Function:  methodSelector,
		Arguments: arguments,
	}

	// This is unlikely, but a generic method invocation can also have its
	// generic types specified explicitly.
	translatedTypeArguments, err := t.translateTypeArguments(typeArguments)
	if err != nil {
		return nil, err
	}
	if translatedTypeArguments != nil {
		fields := &mast.JavaCallExpressionFields{
			TypeArguments: translatedTypeArguments,
		}
		result.LangFields = fields
	}

	return result, nil
}

// scopedIdentifier translates scoped_identifier to mast.AccessPath.
func (t *JavaTranslator) scopedIdentifier(node *ts.Node) (mast.Node, error) {
	// scoped_identifier has two children: scope and name
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	scope, name := node.Children[0], node.Children[1]

	// translate and cast scope
	translatedScope, err := t.Translate(scope)
	if err != nil {
		return nil, err
	}
	castScope, ok := translatedScope.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedScope)
	}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}

	result := &mast.AccessPath{
		Operand: castScope,
		Field:   castName,
	}
	return result, nil
}

// ternaryExpression translates ternary_expression to mast.JavaTernaryExpression.
func (t *JavaTranslator) ternaryExpression(node *ts.Node) (mast.Node, error) {
	// ternary_expression must have three children: condition, consequence and alternative
	if len(node.Children) != 3 {
		return nil, childrenNumberError(node)
	}

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}

	result := &mast.JavaTernaryExpression{
		Condition:   expressions[0],
		Consequence: expressions[1],
		Alternative: expressions[2],
	}
	return result, nil
}

// annotation translates annotation to mast.Annotation.
func (t *JavaTranslator) annotation(node *ts.Node) (mast.Node, error) {
	// annotation can have 1 or 2 children: name, arguments (optional).
	name, arguments := node.ChildByField("name"), node.ChildByField("arguments")
	// only arguments can be optional
	if name == nil {
		return nil, nilChildError(node)
	}

	result := &mast.Annotation{}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	if err := mast.SetJavaExprTypeKinds(castName); err != nil {
		return nil, err
	}
	result.Name = castName

	// early return if arguments node does not exist
	if arguments == nil {
		return result, nil
	}

	// translate arguments, the arguments is a wrapper node "argument_list" that contains multiple expression nodes as
	// the arguments. In MAST we do not care about this wrapper and hence we directly translate all arguments.Children
	// here and put the translated children to the corresponding fields.
	translatedArguments, err := translateNodes(t, arguments.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	// if only one simple argument is present, and it is not in key-value pair form, create one for it for better
	// unification.
	if len(translatedArguments) == 1 {
		n, ok := translatedArguments[0].(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedArguments[0])
		}
		if _, ok := translatedArguments[0].(*mast.KeyValuePair); !ok {
			// JLS states that the key of a single element annotation defaults "value".
			// https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-SingleElementAnnotation
			translatedArguments[0] = &mast.KeyValuePair{
				Key:   &mast.Identifier{Name: "value"},
				Value: n,
			}
		}
	}

	// cast all argument nodes to KeyValuePair nodes to be stored in Annotation.
	castArguments := make([]mast.Expression, len(translatedArguments))
	for i, pair := range translatedArguments {
		p, ok := pair.(*mast.KeyValuePair)
		if !ok {
			return nil, nodeTypeError(pair)
		}
		key, ok := p.Key.(*mast.Identifier)
		if !ok {
			// according to the JLS, the key in an annotation has to be an identifier:
			// https://docs.oracle.com/javase/specs/jls/se11/html/jls-9.html#jls-9.7.1
			return nil, nodeTypeError(p.Key)
		}

		// the key represents a method declared in
		// mast.JavaAnnotationElementDeclaration
		key.Kind = mast.Method

		castArguments[i] = p
	}
	result.Arguments = castArguments
	return result, nil
}

// annotatedType translates annotated_type to mast.JavaAnnotatedType.
func (t *JavaTranslator) annotatedType(node *ts.Node) (mast.Node, error) {
	// annotated_type must have at least 2 children: list of annotations (anonymous), type (anonymous)
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}
	annotations, typeNode := node.Children[:len(node.Children)-1], node.Children[len(node.Children)-1]

	// translate and cast annotations
	castAnnotations, err := translateAnnotations(t, annotations)
	if err != nil {
		return nil, err
	}

	// translate and cast the type.
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	if err := mast.SetJavaExprTypeKinds(castType); err != nil {
		return nil, err
	}

	result := &mast.JavaAnnotatedType{
		Annotations: castAnnotations,
		Type:        castType,
	}
	return result, nil
}

// wildcard translates wild_card to mast.JavaWildcard or mast.JavaAnnotatedType if it is annotated.
func (t *JavaTranslator) wildcard(node *ts.Node) (mast.Node, error) {
	// wildcard can have any number of children, so we skip the length check here.
	// the organization of children is the following:
	// list of annotations (optional, anonymous), super(optional, anonymous), type (optional, anonymous)
	// note that the "extends" keyword is a terminal node therefore not included in the Children slice, but "super" is
	// treated as an identifier node and will be included if it is present.

	// also, tree-sitter puts annotations for the wildcard _inside_ the wildcard node. For better unification, if
	// any annotation node are detected, we extract the annotation nodes and wrap the wildcard node along with the
	// annotation nodes inside a mast.JavaAnnotatedType node.

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	// due to all children being anonymous, we can only infer the children information by their types.
	var annotations []*mast.Annotation

	// the index of iterations
	var i int

	// first we gather all annotation nodes
	for i = 0; i < len(translated); i++ {
		n, ok := translated[i].(*mast.Annotation)
		if ok {
			annotations = append(annotations, n)
		} else {
			// and we break once no annotation nodes remain
			break
		}
	}

	result := &mast.JavaWildcard{}

	// if there are remaining nodes it means there is extends or super keyword present
	if i < len(translated) {
		isSuper := false
		// now check for super keyword
		if n, ok := translated[i].(*mast.Identifier); ok && n.Name == "super" {
			isSuper = true
			// skip the super node
			i++
		}

		// and now we should arrive at the last node, do a check just in case.
		if i != len(translated)-1 {
			return nil, childrenNumberError(node)
		}

		expression, ok := translated[i].(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translated[i])
		}
		// expression represents a type here (e.g. AnotherClazz in
		// Clazz<? extends AnotherClazz>)
		if err := mast.SetJavaExprTypeKinds(expression); err != nil {
			return nil, err
		}

		if isSuper {
			result.Super = expression
		} else {
			result.Extends = expression
		}
	}

	// wrap it inside mast.JavaAnnotatedType if any annotations are present
	if len(annotations) != 0 {
		wrapper := &mast.JavaAnnotatedType{
			Annotations: annotations,
			Type:        result,
		}
		return wrapper, nil
	}

	return result, nil
}

// genericType translates generic_type to mast.JavaGenericType.
func (t *JavaTranslator) genericType(node *ts.Node) (mast.Node, error) {
	// generic_type must have two children: type (anonymous), arguments (anonymous)
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}
	typeNode, arguments := node.Children[0], node.Children[1]

	// translate and cast type node
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	if err := mast.SetJavaExprTypeKinds(castType); err != nil {
		return nil, err
	}

	// translate and cast arguments, arguments contain a list of children where it will be grouped as a
	// mast.TempGroupNode, so here we set the ungroup flag to true.
	translatedArguments, err := translateNodes(t, []*ts.Node{arguments}, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	castArguments, err := toExpressions(translatedArguments)
	if err != nil {
		return nil, err
	}
	// just a reminder - the kinds of type argument are set during
	// type argument translations

	result := &mast.JavaGenericType{
		Name:      castType,
		Arguments: castArguments,
	}
	return result, nil
}

// dimensions translates dimensions to multiple mast.Dimension nodes grouped by mast.TempGroupNode.
func (t *JavaTranslator) dimensions(node *ts.Node) (mast.Node, error) {
	// dimensions can have any number of children, so we skip the check here

	result := &mast.TempGroupNode{}

	// we deployed a fix in tree-sitter that all terminal nodes in dimensions node ("[" and "]") are also collected.
	// these nodes serve as separators and mast.JavaDimension nodes should be created correspondingly.
	// Note that both "[" and "]" are inserted so we need to properly skip the "]" following "[".
	var currentAnnotations []*mast.Annotation
	for i := 0; i < len(node.Children); i++ {
		child := node.Children[i]
		// the child could either be a square node or an annotation node
		if child.Type == "[" {
			// the next child must also be dimension_square
			if i+1 >= len(node.Children) || node.Children[i+1].Type != "]" {
				return nil, fmt.Errorf(`unexpected node %q following "[" for dimensions node`, node.Children[i+1].Type)
			}
			// skip the next "]" node
			i++

			// create a dimension node and attach the current annotations to it.
			dimension := &mast.JavaDimension{
				Annotations: currentAnnotations,
			}
			result.Nodes = append(result.Nodes, dimension)
			// reset the annotation slice for next dimension
			currentAnnotations = nil
		} else {
			// translate annotation node and append to current slice of annotations
			translated, err := t.Translate(child)
			if err != nil {
				return nil, err
			}
			n, ok := translated.(*mast.Annotation)
			if !ok {
				return nil, nodeTypeError(translated)
			}
			currentAnnotations = append(currentAnnotations, n)
		}
	}

	return result, nil
}

// arrayType translates array_type to mast.JavaArrayType.
func (t *JavaTranslator) arrayType(node *ts.Node) (mast.Node, error) {
	// array_type must have two children: element, dimensions.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	element, dimensions := node.Children[0], node.Children[1]
	translatedElement, err := t.Translate(element)
	if err != nil {
		return nil, err
	}
	castElement, ok := translatedElement.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedElement)
	}
	// just a reminder - expressions in an array type are type
	// identifiers (e.g., Clazz in Clazz[] tmp;) or scoped type
	// identifiers (e.g., Foo.Clazz in Foo.Clazz[] tmp;) and are
	// handled when these identifers are translated

	// dimensions will return a slice of mast.JavaDimensions nodes, so we need to ungroup the TempGroupNode here.
	castDimensions, err := translateDimensions(t, dimensions)
	if err != nil {
		return nil, err
	}

	result := &mast.JavaArrayType{
		Name:       castElement,
		Dimensions: castDimensions,
	}

	return result, nil
}

// instanceofExpression translates instanceof_expression to mast.JavaInstanceOfExpression.
func (t *JavaTranslator) instanceofExpression(node *ts.Node) (mast.Node, error) {
	// instanceof_expression must have two children: left, right.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	expressions, err := toExpressions(translated)
	if err != nil {
		return nil, err
	}
	// just a reminder - expression in an instance of clause are type
	// identifiers (e.g., Clazz in obj instance of Clazz) or scoped
	// type identifiers (e.g., Foo.Clazz in obj instance of Foo.Clazz)
	// and are handled when these identifers are translated

	result := &mast.JavaInstanceOfExpression{
		Operand: expressions[0],
		Type:    expressions[1],
	}

	return result, nil
}

// whileStatement translates while_statement to mast.JavaWhileStatement.
func (t *JavaTranslator) whileStatement(node *ts.Node) (mast.Node, error) {
	// while_statement must have 1 or 2 children: condition, body (optional).
	if len(node.Children) != 1 && len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	var condition, body *ts.Node
	if len(node.Children) == 1 {
		condition, body = node.Children[0], nil
	} else {
		condition, body = node.Children[0], node.Children[1]
	}

	result := &mast.JavaWhileStatement{}

	// translate and cast condition
	translatedCondition, err := t.Translate(condition)
	if err != nil {
		return nil, err
	}
	castCondition, ok := translatedCondition.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedCondition)
	}
	result.Condition = castCondition

	// translate and cast body
	if body != nil {
		translatedBody, err := t.Translate(body)
		if err != nil {
			return nil, err
		}
		castBody, ok := translatedBody.(mast.Statement)
		if !ok {
			return nil, nodeTypeError(translatedBody)
		}
		result.Body = castBody
	}

	return result, nil
}

// switchStatement translates switch_statement to mast.SwitchStatement.
func (t *JavaTranslator) switchStatement(node *ts.Node) (mast.Node, error) {
	// switch_statement must have two children: condition and body.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	// the tree structure that tree-sitter generates for switch statement in Java is very different from our MAST
	// designs. Specifically, the body of the switch case is flattened instead of being grouped by case clauses.
	// A typical switch statement structure looks like this:
	// switch_statement:
	//   condition: ...
	//   body:
	//     switch_body:
	//       switch_label (this corresponds to "case X" clause)
	//       statement1 (any kind of statement that actually belongs to the switch_label)
	//       statement2
	//       switch_label2 (another "case Y" clause)
	//       statement3
	//       statement4
	//       ...
	// So here for better unification, we try to group the statements together under mast.SwitchCase node.
	// TODO: this is actually fixed in the master branch of tree-sitter, but not yet released.

	// first translate and cast the nodes
	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	condition, body := translated[0], translated[1]

	// cast to appropriate types for later use
	castCondition, ok := condition.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(condition)
	}
	castBody, ok := body.(*mast.Block)
	if !ok {
		return nil, nodeTypeError(body)
	}

	allCases := []*mast.SwitchCase{}
	// now iterate through the body, collect and tag the statements to the case clause it belongs.
	// remember that switch_label gets translated to mast.SwitchCase with empty Body list.
	var currentCase *mast.SwitchCase
	for _, child := range castBody.Statements {
		switch n := child.(type) {
		case *mast.SwitchCase:
			// reset the current case
			currentCase = n
			allCases = append(allCases, n)
		default:
			// should not happen, but just in case
			if currentCase == nil {
				return nil, errors.New("mismatch switch_label and statements in switch_statement")
			}
			currentCase.Statements = append(currentCase.Statements, n)
		}
	}

	result := &mast.SwitchStatement{
		Value: castCondition,
		Cases: allCases,
	}
	return result, nil
}

// switchLabel translates switch_label to mast.SwitchCase with empty Body.
// See JavaTranslator.switchStatement for how we handle the translations of switch_statement and switch_label.
func (t *JavaTranslator) switchLabel(node *ts.Node) (mast.Node, error) {
	// switch_label can have 0-1 children: value (optional for default case).
	if len(node.Children) > 1 {
		return nil, childrenNumberError(node)
	}

	result := &mast.SwitchCase{}

	// early return if it is a default case
	if len(node.Children) == 0 {
		return result, nil
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	value, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result.Values = []mast.Expression{value}
	return result, nil
}

// throwStatement translates throw_statement to mast.JavaThrowStatement.
func (t *JavaTranslator) throwStatement(node *ts.Node) (mast.Node, error) {
	// throw_statement must have one child: expr (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	expression, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.JavaThrowStatement{
		Expr: expression,
	}

	return result, nil
}

// assertStatement translates assert_statement to mast.JavaAssertStatement.
func (t *JavaTranslator) assertStatement(node *ts.Node) (mast.Node, error) {
	// assert_statement must have 1 or 2 childdren: condition (anonymous), error (optional, anonymous).
	if len(node.Children) != 1 && len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	var condition, errorString *ts.Node
	if len(node.Children) == 1 {
		condition, errorString = node.Children[0], nil
	} else {
		condition, errorString = node.Children[0], node.Children[1]
	}

	result := &mast.JavaAssertStatement{}

	// translate and cast condition
	translatedCondition, err := t.Translate(condition)
	if err != nil {
		return nil, err
	}
	castCondition, ok := translatedCondition.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedCondition)
	}
	result.Condition = castCondition

	// translate and cast error string
	if errorString != nil {
		translatedErrorString, err := t.Translate(errorString)
		if err != nil {
			return nil, err
		}
		castErrorString, ok := translatedErrorString.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedErrorString)
		}
		result.ErrorString = castErrorString
	}

	return result, nil
}

// synchronizedStatement translates synchronized_statement to mast.JavaSynchronizedStatement.
func (t *JavaTranslator) synchronizedStatement(node *ts.Node) (mast.Node, error) {
	// synchronized_statement must have 2 children: expression (anonymous), block.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}
	expression, block := node.Children[0], node.Children[1]

	translatedExpression, err := t.Translate(expression)
	if err != nil {
		return nil, err
	}
	castExpression, ok := translatedExpression.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedExpression)
	}

	translatedBlock, err := t.Translate(block)
	if err != nil {
		return nil, err
	}
	castBlock, ok := translatedBlock.(*mast.Block)
	if !ok {
		return nil, nodeTypeError(translatedBlock)
	}

	result := &mast.JavaSynchronizedStatement{
		Expr: castExpression,
		Body: castBlock,
	}

	return result, nil
}

// doStatement translates do_statement to mast.JavaDoStatement.
func (t *JavaTranslator) doStatement(node *ts.Node) (mast.Node, error) {
	// do_statement must have 2 children: body, condition.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	body, condition := node.Children[0], node.Children[1]

	// translate and cast body
	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}
	castBody, ok := translatedBody.(mast.Statement)
	if !ok {
		return nil, nodeTypeError(translatedBody)
	}

	// translate and cast condition
	translatedCondition, err := t.Translate(condition)
	if err != nil {
		return nil, err
	}
	castCondition, ok := translatedCondition.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedCondition)
	}

	result := &mast.JavaDoStatement{
		Body:      castBody,
		Condition: castCondition,
	}

	return result, nil
}

// catchFormalParameter translates catch_formal_parameter to mast.JavaCatchFormalParameters.
func (t *JavaTranslator) catchFormalParameter(node *ts.Node) (mast.Node, error) {
	// catch_formal_parameters must have 2-4 children:
	// modifiers (optional, anonymous), catch_type (anonymous), name, dimensions (optional).
	if len(node.Children) < 2 || len(node.Children) > 4 {
		return nil, childrenNumberError(node)
	}

	// assign the nodes correctly, where non-existent node is set to nil
	name, dimensions := node.ChildByField("name"), node.ChildByField("dimensions")
	var modifiers, catchType *ts.Node
	if node.Children[0].Type == "modifiers" {
		modifiers, catchType = node.Children[0], node.Children[1]
	} else {
		modifiers, catchType = nil, node.Children[0]
	}

	result := &mast.JavaCatchFormalParameter{}

	// translate and cast modifiers
	if modifiers != nil {
		castModifiers, err := translateModifiers(t, modifiers)
		if err != nil {
			return nil, err
		}
		result.Modifiers = castModifiers
	}

	// translate and cast types
	// catch_type could contain a slice of multiple exception types connected by "|", e.g., "IOException|SQLException".
	// Therefore here we un-group them.
	translatedTypes, err := translateNodes(t, []*ts.Node{catchType}, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	castTypes, err := toExpressions(translatedTypes)
	if err != nil {
		return nil, err
	}
	// just a reminder - expressions in a catch clause are type
	// identifiers (e.g., Clazz ...catch(Clazz)...) or scoped type
	// identifiers (e.g., Foo.Clazz in ...catch(Foo.Clazz)...)  and
	// are handled when these identifers are translated

	result.Types = castTypes

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	// translate and cast dimensions
	if dimensions != nil {
		castDimensions, err := translateDimensions(t, dimensions)
		if err != nil {
			return nil, err
		}
		result.Dimensions = castDimensions
	}

	return result, nil
}

// catchClause translates catch_clause to mast.CatchClause.
func (t *JavaTranslator) catchClause(node *ts.Node) (mast.Node, error) {
	// catch_clause must have 2 children: catch_formal_parameters, body.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	parameters, body := node.Children[0], node.Children[1]

	translatedParameters, err := t.Translate(parameters)
	if err != nil {
		return nil, err
	}
	castParameters, ok := translatedParameters.(*mast.JavaCatchFormalParameter)
	if !ok {
		return nil, nodeTypeError(translatedParameters)
	}

	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}
	castBody, ok := translatedBody.(*mast.Block)
	if !ok {
		return nil, nodeTypeError(translatedBody)
	}

	result := &mast.JavaCatchClause{
		Parameter: castParameters,
		Body:      castBody,
	}

	return result, nil
}

// finallyClause translates finally_clause to mast.JavaFinallyClause.
func (t *JavaTranslator) finallyClause(node *ts.Node) (mast.Node, error) {
	// finally_clause must have 1 child: body (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	body, ok := translated.(*mast.Block)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	result := &mast.JavaFinallyClause{
		Body: body,
	}

	return result, nil
}

// tryStatement translates try_statement/try_with_resources_statement to mast.JavaTryStatement.
func (t *JavaTranslator) tryStatement(node *ts.Node) (mast.Node, error) {
	// tryStatement handles the translations of try_statement and try_with_resources_statement, where the only
	// difference is that try_with_resources_statement has an additional and optional field: resources.
	// try_statement/try_with_resources_statement must have at least two children:
	// resources (optional), body, list of catch_clause nodes (optional), finally_clause (optional), where one
	// catch_clause or finally_clause must be present.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaTryStatement{}

	// due to the diversity of children types, here we construct JavaTryStatement based on the type of children.
	// Children might contain resource_specification node which is a wrapper node that will be translated to multiple
	// mast.Statement nodes. Therefore here we un-group them.
	translated, err := translateNodes(t, node.Children, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	for _, node := range translated {
		switch n := node.(type) {
		case *mast.Block:
			result.Body = n
		// A resource node will be translated to either mast.ExpressionStatement or mast.DeclarationStatement.
		case mast.Statement:
			result.Resources = append(result.Resources, n)
		case *mast.JavaCatchClause:
			result.CatchClauses = append(result.CatchClauses, n)
		case *mast.JavaFinallyClause:
			result.Finally = n
		default:
			return nil, nodeTypeError(node)
		}
	}

	return result, nil
}

// modifiers translates modifiers to multiple mast.JavaLiteralModifier or mast.Annotation nodes grouped by
// mast.TempGroupNode.
func (t *JavaTranslator) modifiers(node *ts.Node) (mast.Node, error) {
	// modifiers contain a list of modifiers with at least one element.
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	legalModifiers := map[string]bool{
		mast.PublicMod:       true,
		mast.ProtectedMod:    true,
		mast.PrivateMod:      true,
		mast.AbstractMod:     true,
		mast.StaticMod:       true,
		mast.FinalMod:        true,
		mast.StrictfpMod:     true,
		mast.DefaultMod:      true,
		mast.SynchronizedMod: true,
		mast.NativeMod:       true,
		mast.TransientMod:    true,
		mast.VolatileMod:     true,
	}

	result := &mast.TempGroupNode{}

	// the children could either be a literal modifier or an annotation
	for _, child := range node.Children {
		// for literal modifiers
		if exists := legalModifiers[child.Type]; exists {
			n := &mast.JavaLiteralModifier{
				Modifier: child.Type,
			}
			result.Nodes = append(result.Nodes, n)
			continue
		}
		// for java annotation nodes
		translated, err := t.Translate(child)
		if err != nil {
			return nil, err
		}
		castModifier, ok := translated.(*mast.Annotation)
		if !ok {
			return nil, nodeTypeError(translated)
		}
		result.Nodes = append(result.Nodes, castModifier)
	}

	return result, nil
}

// formalParameter translates formal_parameter and spread_parameter to mast.ParameterDeclaration.
func (t *JavaTranslator) formalParameter(node *ts.Node) (mast.Node, error) {
	// This method handles the translations of both formal_parameter nodes and spread_parameter nodes since
	// spread_parameter is a special case of formal_parameter. They share some common fields in their structures:
	// - formal_parameter must have 2-4 children: modifiers (optional, anonymous), type, name, dimensions (optional).
	// - spread_parameter must have 2-3 children: modifiers (optional, anonymous), type (anonymous), variable_declarator (anonymous).
	// Here in spread_parameter the last child variable_declarator is a wrapper of a variable name with optional
	// dimensions ("a[][]") and initializers ("a = 5"). Note that variable_declarator will be translated to an
	// intermediate MAST node mast.JavaVariableDeclarator. For better unification, we will simply extract the fields and
	// assign them accordingly to the mast.ParameterDeclaration node we are building here.

	// TODO: for spread_parameter, the last child is a variable_declarator node. However, JLS [1] disagrees with
	// tree-sitter here and indicates that the last child is simply an identifier (i.e., no dimensions and initializers
	// are actually allowed). This will not cause an issue since the initializer and dimensions in variable_declaration
	// are both optional. However, tree-sitter will likely fix the structure in the future and we should update our
	// translations accordingly. For example, a parameter list such as "(Type1 t1, Type2 ...t2)" contains a
	// formal_parameter and a spread_parameter, the tree-sitter structure is as follows (unrelated part of the tree is
	// omitted for brevity):
	// formal_parameter:
	//   - type_identifier "Type1"
	//   - identifier "t1"
	// spread_parameter:
	//   - type_identifier "Type2"
	//   - variable_declarator <-- It is a variable_declarator node, but JLS says this should just be an identifier.
	//       - identifier: "a"
	//       - ....            <-- tree-sitter allows dimensions and initializer nodes here, but in fact JLS forbids it.
	// So here what we do is that we simply ignore dimensions and initializer nodes and only extract the name field.
	// Also, an extra check is added to assert that dimensions and initializer nodes should not exist.
	// [1] https://docs.oracle.com/javase/specs/jls/se11/html/jls-8.html#jls-8.4.1
	if len(node.Children) < 2 || len(node.Children) > 4 {
		return nil, childrenNumberError(node)
	}

	// first translate the common fields: modifiers and name
	var modifiers, typeNode *ts.Node
	if node.Children[0].Type == "modifiers" {
		modifiers, typeNode = node.Children[0], node.Children[1]
	} else {
		modifiers, typeNode = nil, node.Children[0]
	}

	// put the pointer of the extra node on the result here so that later edits of the extra node will automatically be
	// reflected on the result.
	extra := &mast.JavaParameterDeclarationFields{}
	result := &mast.ParameterDeclaration{LangFields: extra}

	if modifiers != nil {
		castModifiers, err := translateModifiers(t, modifiers)
		if err != nil {
			return nil, err
		}
		extra.Modifiers = castModifiers
	}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	// just a reminder - expressions in a formal parameter declaration
	// are type identifiers (e.g., Clazz in foo(Clazz tmp){}) or
	// scoped type identifiers (e.g., Foo.Clazz in foo(Foo.Clazz
	// tmp){}) and are handled when these identifers are translated
	result.Type = castType

	switch node.Type {
	case "formal_parameter":
		name, dimensions := node.ChildByField("name"), node.ChildByField("dimensions")
		// translate and cast name
		translatedName, err := t.Translate(name)
		if err != nil {
			return nil, err
		}
		castName, ok := translatedName.(*mast.Identifier)
		if !ok {
			return nil, nodeTypeError(translatedName)
		}
		result.Name = castName

		if dimensions != nil {
			castDimensions, err := translateDimensions(t, dimensions)
			if err != nil {
				return nil, err
			}
			extra.Dimensions = castDimensions
		}
	case "spread_parameter":
		// first set variadic flag
		result.IsVariadic = true

		// variable_declarator must be the last child.
		declarator := node.Children[len(node.Children)-1]
		if declarator.Type != "variable_declarator" {
			return nil, fmt.Errorf("unexpected node type encountered: expected variable_declarator, got %q", declarator.Type)
		}
		// translate and cast declarator
		translatedDeclarator, err := t.Translate(declarator)
		if err != nil {
			return nil, err
		}
		castDeclarator, ok := translatedDeclarator.(*mast.JavaVariableDeclarator)
		if !ok {
			return nil, nodeTypeError(translatedDeclarator)
		}
		result.Name = castDeclarator.Name

		// This is not allowed according to the JLS, even through tree-sitter has the fields for it. See the TODO note
		// at the begining of this method for additional explanations.
		if castDeclarator.Dimensions != nil || castDeclarator.Initializer != nil {
			return nil, errors.New("spread_parameter contains dimensions or initializer")
		}
	}

	return result, nil
}

// variableDeclarator translates variable_declarator to mast.JavaVariableDeclarator. Note that it is only meant to be
// an intermediate node that will eventually be unwrapped by the translations of other nodes.
// See mast.JavaVariableDeclarator for detailed explanation.
func (t *JavaTranslator) variableDeclarator(node *ts.Node) (mast.Node, error) {
	// variable_declarator must have at least one child: name, dimensions (optional), value (optional).
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	name, dimensions, value := node.ChildByField("name"), node.ChildByField("dimensions"), node.ChildByField("value")
	// name cannot be nil
	if name == nil {
		return nil, nilChildError(node)
	}

	result := &mast.JavaVariableDeclarator{}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	if dimensions != nil {
		castDimensions, err := translateDimensions(t, dimensions)
		if err != nil {
			return nil, err
		}
		result.Dimensions = castDimensions
	}

	if value != nil {
		// translate and cast value
		translatedValue, err := t.Translate(value)
		if err != nil {
			return nil, err
		}
		castValue, ok := translatedValue.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedValue)
		}
		result.Initializer = castValue
	}

	return result, nil
}

// inferredParameters translates inferred_parameters to multiple mast.ParameterDeclaration grouped by mast.TempGroupNode.
func (t *JavaTranslator) inferredParameters(node *ts.Node) (mast.Node, error) {
	// inferred_parameter must have at least one child: list of identifiers (anonymous).
	// inferred_parameter is just a special case for formal_parameter where no other information except the identifier
	// is given.
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}
	translatedIdentifiers, err := translateNodes(t, node.Children, false /* shouldUngroup*/)
	if err != nil {
		return nil, err
	}

	result := &mast.TempGroupNode{}
	for _, ident := range translatedIdentifiers {
		castIdentifier, ok := ident.(*mast.Identifier)
		if !ok {
			return nil, nodeTypeError(ident)
		}

		temp := &mast.ParameterDeclaration{
			Name:       castIdentifier,
			LangFields: &mast.JavaParameterDeclarationFields{},
		}
		result.Nodes = append(result.Nodes, temp)
	}
	return result, nil
}

// receiverParameter translates receiver_parameter to mast.ParameterDeclaration.
func (t *JavaTranslator) receiverParameter(node *ts.Node) (mast.Node, error) {
	// receiver_parameter must have at least 2 children:
	// list of annotations (optional, anonymous), type (anonymous), name (optional, anonymous), this.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	// put the pointer of the extra node on the result here so that later edits of the extra node will automatically be
	// reflected on the result.
	extra := &mast.JavaParameterDeclarationFields{}
	result := &mast.ParameterDeclaration{LangFields: extra}

	// Due to the complexities of the children structure, we assign the fields according to the types of the translated
	// children. Notice here we stripped the last element ("this" node) which is not needed (its meaning is absorbed by
	// the IsReceiver flag of JavaParameterDeclarationExtra).
	translated, err := translateNodes(t, node.Children[:len(node.Children)-1], false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	for _, child := range translated {
		switch n := child.(type) {
		case *mast.Annotation:
			extra.Modifiers = append(extra.Modifiers, n)
		case mast.Expression:
			// The current node must be type if type is not set yet (type always exists and the occurs before name).
			if result.Type == nil {
				// just a reminder - expressions in a receiver
				// parameter declaration are type identifiers (e.g.,
				// Clazz in foo(Clazz this){}) or scoped type
				// identifiers (e.g., Foo.Clazz in foo(Foo.Clazz
				// this){}) and are handled when these identifers are
				// translated
				result.Type = n
				continue
			}
			// Otherwise it must be name, so we further cast it to Identifier.
			name, ok := n.(*mast.Identifier)
			if !ok {
				return nil, nodeTypeError(n)
			}
			result.Name = name
		default:
			return nil, nodeTypeError(child)
		}
	}

	return result, nil
}

// lambdaExpression translates lambda_expression to mast.FunctionLiteral.
func (t *JavaTranslator) lambdaExpression(node *ts.Node) (mast.Node, error) {
	// lambda_expression must have 2 children: parameters, body.
	if len(node.Children) != 2 {
		return nil, childrenNumberError(node)
	}

	parameters, body := node.Children[0], node.Children[1]

	// parameters could potentially be an inferred_parameter, which will be translated to multiple
	// mast.ParameterDeclaration nodes grouped by mast.TempGroupNode. Therefore we un-group them here.
	var castParameters []mast.Declaration
	if len(parameters.Children) != 0 {
		translatedParameters, err := translateNodes(t, []*ts.Node{parameters}, true /* shouldUngroup*/)
		if err != nil {
			return nil, err
		}
		castParameters = make([]mast.Declaration, len(translatedParameters))
		for i, param := range translatedParameters {
			n, ok := param.(*mast.ParameterDeclaration)
			if !ok {
				return nil, nodeTypeError(param)
			}
			castParameters[i] = n
		}
	}

	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}

	// wrap it inside an mast.ExpressionStatement node if it is an expression
	var statements []mast.Statement
	switch n := translatedBody.(type) {
	case mast.Expression:
		statements = []mast.Statement{&mast.ExpressionStatement{Expr: n}}
	case *mast.Block:
		statements = n.Statements
	default:
		return nil, nodeTypeError(translatedBody)
	}

	result := &mast.FunctionLiteral{
		Parameters: castParameters,
		Statements: statements,
	}

	return result, nil
}

// localVariableDeclaration translates local_variable_declaration to multiple mast.VariableDeclaration nodes grouped
// by mast.TempGroupNode. For example, "int a = 1, b = 3;" will be translated to "int a = 1" and "int b = 3;".
func (t *JavaTranslator) localVariableDeclaration(node *ts.Node) (mast.Node, error) {
	// local_variable_declaration must have at least 2 children:
	// modifiers (optional, anonymous), type, list of declarator nodes.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	var modifiers *ts.Node
	if node.Children[0].Type == "modifiers" {
		modifiers = node.Children[0]
	}

	typeNode, declarators := node.ChildByField("type"), node.ChildrenByField("declarator")

	result := &mast.TempGroupNode{}
	// translate and unwrap declarators, create mast.JavaVariableDeclaration nodes based on declarator list.
	// Note that we do not have to un-group here because tree-sitter will generate multiple _separate_
	// variable_declarator nodes for declarations such as "String a, b". An example tree would look like this:
	// local_variable_declaration:
	//   - type_identifier: String
	//   - variable_declarator:
	//       - identifier: "a"
	//   - variable_declarator:
	//       - identifier: "b"
	// Therefore here we unwrap the variable_declarator nodes and create mast.JavaVariableDeclaration nodes based on
	// their children, combined with modifiers and type nodes here.
	for _, declarator := range declarators {
		// should not happen, but just to be safe
		if declarator.Type != "variable_declarator" {
			return nil, fmt.Errorf("unexpected node type encountered: expected variable_declarator, got %q", declarator.Type)
		}
		// unwrap and retrieve its children
		name, dimensions, value := declarator.ChildByField("name"), declarator.ChildByField("dimensions"), declarator.ChildByField("value")

		// create mast.JavaVariableDeclaration
		declaration, err := translateVariableDeclaration(t, modifiers, typeNode, name, dimensions, value)
		if err != nil {
			return nil, err
		}
		result.Nodes = append(result.Nodes, declaration)
	}

	return result, nil
}

// forStatement translates for_statement to mast.ForStatement.
func (t *JavaTranslator) forStatement(node *ts.Node) (mast.Node, error) {
	// for_statement must have at least 1 children:
	// list of init nodes (optional), condition (optional), list of update nodes (optional), body.
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	initializers, condition, updates := node.ChildrenByField("init"), node.ChildByField("condition"), node.ChildrenByField("update")
	body := node.ChildByField("body")

	result := &mast.ForStatement{}

	if initializers != nil {
		// initializers could contain multiple variable declarations such as "int i, k", which will be translated to
		// multiple declaration nodes grouped by mast.TempGroupNode, therefore here we un-group them.
		translatedInitializers, err := translateNodes(t, initializers, true /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castInitializers, err := toStatements(translatedInitializers)
		if err != nil {
			return nil, err
		}
		result.Initializers = castInitializers
	}

	if condition != nil {
		// translate and cast condition
		translatedCondition, err := t.Translate(condition)
		if err != nil {
			return nil, err
		}
		castCondition, ok := translatedCondition.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedCondition)
		}
		result.Condition = castCondition
	}

	if updates != nil {
		translatedUpdates, err := translateNodes(t, updates, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castUpdates, err := toStatements(translatedUpdates)
		if err != nil {
			return nil, err
		}
		result.Updates = castUpdates
	}

	// translate and cast body
	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}
	// if body is a single statement, wrap it inside a *mast.Block node
	switch n := translatedBody.(type) {
	case *mast.Block:
		// only set the body if it is not empty
		if len(n.Statements) != 0 {
			result.Body = n
		}
	case mast.Statement:
		result.Body = &mast.Block{
			Statements: []mast.Statement{n},
		}
	default:
		return nil, nodeTypeError(translatedBody)
	}

	return result, nil
}

// enhancedForStatement translates enhanced_for_statement to mast.EnhancedForStatement.
func (t *JavaTranslator) enhancedForStatement(node *ts.Node) (mast.Node, error) {
	// enhanced_for_statement must have 4-6 children: modifiers (optional), type, name, dimensions (optional), value, body.
	if len(node.Children) < 4 || len(node.Children) > 6 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaEnhancedForStatement{}

	if node.Children[0].Type == "modifiers" {
		modifiers := node.Children[0]
		castModifiers, err := translateModifiers(t, modifiers)
		if err != nil {
			return nil, err
		}
		result.Modifiers = castModifiers
	}

	typeNode, name, dimensions := node.ChildByField("type"), node.ChildByField("name"), node.ChildByField("dimensions")
	value, body := node.ChildByField("value"), node.ChildByField("body")

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	result.Type = castType

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	// translate and cast value
	translatedValue, err := t.Translate(value)
	if err != nil {
		return nil, err
	}
	castValue, ok := translatedValue.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedValue)
	}
	result.Iterable = castValue

	// translate and cast dimensions
	if dimensions != nil {
		castDimensions, err := translateDimensions(t, dimensions)
		if err != nil {
			return nil, err
		}
		result.Dimensions = castDimensions
	}

	// translate and cast body
	translatedBody, err := t.Translate(body)
	if err != nil {
		return nil, err
	}
	// if body is a single statement, wrap it inside a *mast.Block node
	switch n := translatedBody.(type) {
	case *mast.Block:
		// only set the body if it is not empty
		if len(n.Statements) != 0 {
			result.Body = n
		}
	case mast.Statement:
		result.Body = &mast.Block{
			Statements: []mast.Statement{n},
		}
	default:
		return nil, nodeTypeError(translatedBody)
	}

	return result, nil
}

// objectCreationExpression translates object_creation_expression to mast.EntityCreationExpression.
// Note that although the object creation expression in Java looks similar to a function call ("new Test(1, 2, 3)"),
// for better unification we treat it more like a composite literal structure (i.e., "Test{1, 2, 3}"), where the
// initializer is the function arguments (the "1, 2, 3" here). Therefore, the example object creation expression will be
// translated to the following structure (un-related parts are omitted for brevity):
// EntityCreationExpression
// - Type: "Test"
// - Value: LiteralValue
//   - IntLiteral: 1
//   - IntLiteral: 2
//   - IntLiteral: 3
func (t *JavaTranslator) objectCreationExpression(node *ts.Node) (mast.Node, error) {
	// object_creation_expression could have 2-4 children:
	// object (optional, anonymous), type, arguments, class_body (optional, anonymous).
	if len(node.Children) < 2 || len(node.Children) > 4 {
		return nil, childrenNumberError(node)
	}

	var object, classBody *ts.Node
	typeNode, arguments := node.ChildByField("type"), node.ChildByField("arguments")

	if node.Children[0] != typeNode {
		object = node.Children[0]
	}

	if len(node.Children) >= 3 && node.Children[len(node.Children)-1] != arguments {
		classBody = node.Children[len(node.Children)-1]
	}

	result := &mast.EntityCreationExpression{}

	// translate and cast object
	if object != nil {
		translatedObject, err := t.Translate(object)
		if err != nil {
			return nil, err
		}
		castObject, ok := translatedObject.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedObject)
		}
		result.Object = castObject
	}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	if err := mast.SetJavaCallKind(castType, mast.Method); err != nil {
		return nil, err
	}
	result.Type = castType

	if len(arguments.Children) != 0 {
		// arguments is an argument_list node which is a wrapper node containing multiple expressions of the arguments,
		// therefore here we unwrap it by directly passing arguments.Children.
		translatedArguments, err := translateNodes(t, arguments.Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castArguments, err := toExpressions(translatedArguments)
		if err != nil {
			return nil, err
		}
		result.Value = &mast.LiteralValue{Values: castArguments}
	}

	if classBody != nil {
		castBody, err := translateClassBody(t, classBody)
		if err != nil {
			return nil, err
		}
		extra := &mast.JavaEntityCreationExpressionFields{}
		extra.Body = castBody
		result.LangFields = extra
	}

	return result, nil
}

// arrayCreationExpression translates array_creation_expression to mast.EntityCreationExpression.
func (t *JavaTranslator) arrayCreationExpression(node *ts.Node) (mast.Node, error) {
	// array_creation_expression must have at least 2 children: type, multiple dimensions, value (optional),
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	// The structure tree-sitter generates for array_creation_expression is slightly inconsistent, so here we fix them
	// into a uniform MAST structure. The structure of children could be one of the following:
	// (1) with initializer (e.g., "new int[][]{{1}, {2}, {3}}"): type, one "dimensions" node (containing multiple children)
	//     and value must exist.
	//     array_creation_expression:
	//	     - type
	//       - dimensions (just one node for the two dimensions "[][]", see the translations of "dimensions" for details)
	//       - array_initializer
	//           - ...
	// (2) without initializer (e.g., "new int[4][5]"): type, _multiple_ "dimensions_expr" nodes must exist (somehow
	//     flattened and are directly available in node.Children), and value node cannot exist.
	//     array_creation_expression:
	//       - type
	//       - dimensions_expr (for "[4]")
	//       - dimensions_expr (for "[5]")

	// Notice the "ChildrenByField" call for "dimensions" due to case (2).
	typeNode, dimensions, value := node.ChildByField("type"), node.ChildrenByField("dimensions"), node.ChildByField("value")

	extra := &mast.JavaEntityCreationExpressionFields{}
	result := &mast.EntityCreationExpression{LangFields: extra}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	result.Type = castType

	// translate and cast dimensions
	// As explained above, dimensions could either be ["dimensions"] or ["dimensions_expr", "dimensions_expr", ...].
	// "dimensions" will be translated to multiple mast.JavaDimension nodes grouped by mast.TempGroupNode, therefore
	// we un-group them here.
	translatedDimensions, err := translateNodes(t, dimensions, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	extra.Dimensions = make([]*mast.JavaDimension, len(translatedDimensions))
	for i, d := range translatedDimensions {
		castDimension, ok := d.(*mast.JavaDimension)
		if !ok {
			return nil, nodeTypeError(d)
		}
		extra.Dimensions[i] = castDimension
	}

	// translate and cast value
	if value != nil {
		translatedValue, err := t.Translate(value)
		if err != nil {
			return nil, err
		}
		castValue, ok := translatedValue.(*mast.LiteralValue)
		if !ok {
			return nil, nodeTypeError(translatedValue)
		}
		result.Value = castValue
	}

	return result, nil
}

// dimensionsExpr translates dimensions_expr to mast.JavaDimension.
func (t *JavaTranslator) dimensionsExpr(node *ts.Node) (mast.Node, error) {
	// dimensions_expr must have at least one child: list of annotations (optional, anonymous), length (anonymous).
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaDimension{}
	translated, err := translateNodes(t, node.Children, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	// here we infer the type of children based on its translated type
	for _, child := range translated {
		switch n := child.(type) {
		case *mast.Annotation:
			result.Annotations = append(result.Annotations, n)
		case mast.Expression:
			// must not happend, just for sanity check
			if result.Length != nil {
				return nil, fmt.Errorf("more than one length node %T appears in dimensions_expr", child)
			}
			result.Length = n
		default:
			return nil, nodeTypeError(child)
		}
	}

	return result, nil
}

// requiresModifier translates requires_modifier to mast.JavaLiteralModifier.
func (t *JavaTranslator) requiresModifier(node *ts.Node) (mast.Node, error) {
	// requires_modifier must not have children.
	if len(node.Children) != 0 {
		return nil, childrenNumberError(node)
	}

	// The only valid modifiers are transitive and static.
	modifier := node.Name
	if modifier != "transitive" && modifier != "static" {
		return nil, fmt.Errorf("illegal modifier for requires directive: %q", modifier)
	}

	result := &mast.JavaLiteralModifier{
		Modifier: modifier,
	}

	return result, nil
}

// moduleDeclaration translates module_declaration to mast.ModuleDeclaration.
func (t *JavaTranslator) moduleDeclaration(node *ts.Node) (mast.Node, error) {
	// A fix in tree-sitter package is deployed to also include the terminal children nodes so that we can determine
	// whether "open" modifier is present. As a side-effect, "module" terminal node is also included which we will have
	// to skip during the translation.

	// module_declaration must have at least 3 children:
	// list of annotations (optional), open keyword (optional), module keyword, name, body.
	if len(node.Children) < 3 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaModuleDeclaration{}

	// first collect all optional annotation nodes
	for _, child := range node.Children {
		// If we encounter "open" modifier, it means we have iterated all annotation nodes.
		if child.Type == "open" {
			// mark the declaration as open
			result.IsOpen = true
			break
		}
		// If we encounter "module" keyword we have iterated all annotation nodes.
		if child.Type == "module" {
			break
		}
		translated, err := t.Translate(child)
		if err != nil {
			return nil, err
		}
		cast, ok := translated.(*mast.Annotation)
		if !ok {
			return nil, nodeTypeError(translated)
		}
		result.Annotations = append(result.Annotations, cast)
	}

	name, body := node.ChildByField("name"), node.ChildByField("body")

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	// early return if body is empty
	if len(body.Children) == 0 {
		return result, nil
	}

	// body is a module_body node containing a list of module_directive nodes, which will be translated to multiple
	// mast.JavaModuleDirective nodes grouped by mast.TempGroupNode. Therefore we un-group them here.
	directives, err := translateNodes(t, []*ts.Node{body}, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	// cast the directives
	result.Directives = make([]*mast.JavaModuleDirective, len(directives))
	for i, child := range directives {
		n, ok := child.(*mast.JavaModuleDirective)
		if !ok {
			return nil, nodeTypeError(child)
		}
		result.Directives[i] = n
	}

	return result, nil
}

// moduleDirective translates module_directive to mast.ModuleDirective.
func (t *JavaTranslator) moduleDirective(node *ts.Node) (mast.Node, error) {
	// We deployed a fix in tree-sitter package to also include terminal nodes in module_directive, and the meaning of
	// the module directive depends on the keyword. Therefore the actual number of children may vary, but this node must
	// have at least two children: keyword and name, both anonymous.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}
	// Possible structures are (the parentheses are not terminals but indicators that the elements are optional):
	// (1) requires (RequiresModifier) ModuleName ;
	// (2) exports PackageName  ;
	// (3) opens PackageName (to ModuleName, ModuleName, ....) ;
	// (4) uses TypeName ;
	// (5) provides TypeName with TypeName (, TypeName, TypeName ...) ;

	// We first get the keyword and then collect the rest of the expressions.
	result := &mast.JavaModuleDirective{
		Keyword: node.Children[0].Type,
	}
	for _, child := range node.Children[1:] {
		// skip unnecessary terminal nodes
		if child.Type == "to" || child.Type == "with" || child.Type == "," || child.Type == ";" {
			continue
		}
		translated, err := t.Translate(child)
		if err != nil {
			return nil, err
		}
		cast, ok := translated.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translated)
		}
		result.Exprs = append(result.Exprs, cast)
	}

	return result, nil
}

// typeParameter translates type_parameter to mast.JavaTypeParameter.
func (t *JavaTranslator) typeParameter(node *ts.Node) (mast.Node, error) {
	// type_parameter must have at least 1 child: slice of annotations (optional), type (anonymous), type_bound (optional, anonymous)
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaTypeParameter{}

	// due to the diversity of types of children, here we can translate all children and put the the translated nodes in
	// the corresponding fields purely based on their types.
	// Note that type_bound child may contain multiple type nodes (e.g, "<A extends B, C>") therefore will be translated
	// to multiple mast.Expression nodes (types) grouped by mast.TempGroupNode. Therefore we un-group them here.
	translated, err := translateNodes(t, node.Children, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	for _, child := range translated {
		switch n := child.(type) {
		case *mast.Annotation:
			result.Annotations = append(result.Annotations, n)
		case mast.Expression:
			// Both the type and type_bounds will be of the type mast.Expression, however, the first one is the type and
			// the rest are the extends.

			//  n represents a type with the caveat that the type can
			//  actually be a wild card (e.g., AnotherClazz<?  extends
			//  String> but it's OK to mark it as type kind as it's
			//  not a valid Java identifier and will never be matched
			//  with anything.
			if err := mast.SetJavaExprTypeKinds(n); err != nil {
				return nil, err
			}

			if result.Type == nil {
				result.Type = n
			} else {
				result.Extends = append(result.Extends, n)
			}

		default:
			return nil, nodeTypeError(child)
		}
	}

	return result, nil
}

// superclass translates superclass to mast.Expression. The superclass node is a simple wrapper node that wraps around
// the superclass type node. For example,
// class Test extends A {...} would have the following structure (un-related parts are omitted for brevity):
// class_declaration
//
//	...
//	- superclass
//	    - identifier: A
//	...
//
// Therefore, here we simply unwrap the node and return the inner type, which will be later stored properly in a field
// at a upper-level (during the translations of class_declaration)
func (t *JavaTranslator) superclass(node *ts.Node) (mast.Node, error) {
	// superclass must have 1 child: type (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}

	cast, ok := translated.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	return cast, nil
}

// superInterfaces translates super_interfaces to mast.TempGroupNode.
// Similar to superclass node, super_interfaces is also a wrapper node that wraps around an "interface_type_list" nodes,
// which is still a wrapper node wrapping a list of interface types. For example,
// class Test implements C, D {...} will have the following structure (un-related parts are omitted for brevity):
// class_delcaration
//
//	...
//	- super_interfaces
//	    - interface_type_list
//	        - identifier: C
//	        - identifier: D
//	...
//
// Note that even if there is only _one_ super interface, tree-sitter will still generate the same structure except that
// the "interface_type_list" will only have one child.
// We re-used a common translation logic for "interface_type_list" that simply translates all its children and return
// the translated node in mast.TempGroupNode. Therefore, here we just unwrap "super_interfaces" and directly return the
// translated mast.TempGroupNode.
func (t *JavaTranslator) superInterfaces(node *ts.Node) (mast.Node, error) {
	// super_interfaces must have 1 child: interface_type_list (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translated, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}

	cast, ok := translated.(*mast.TempGroupNode)
	if !ok {
		return nil, nodeTypeError(translated)
	}

	return cast, nil
}

// fieldDeclaration translates field_declaration (inter == false) or
// constant_declaration (inter == true) to multiple
// mast.VariableDeclaration nodes grouped by mast.TempGroupNode.
func (t *JavaTranslator) fieldDeclaration(node *ts.Node, inter bool) (mast.Node, error) {
	// field_declaration must have at least 2 children: modifiers (optional, anonymous), type, list of declarator ()
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	var modifiers *ts.Node
	if node.Children[0].Type == "modifiers" {
		modifiers = node.Children[0]
	}

	typeNode, declarators := node.ChildByField("type"), node.ChildrenByField("declarator")
	// these fields must exist
	if typeNode == nil || len(declarators) == 0 {
		return nil, nilChildError(node)
	}

	var castModifiers []mast.Expression
	if modifiers != nil {
		modifiers, err := translateModifiers(t, modifiers)
		if err != nil {
			return nil, err
		}
		castModifiers, err = addImplicitModifiers(node, modifiers, inter)
		if err != nil {
			return nil, err
		}
	}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	// just a reminder - expressions in a field declaration are type
	// identifiers (e.g., Clazz in Clazz tmp) or scoped type
	// identifiers (e.g., Foo.Clazz in Foo.Clazz tmp) and are handled
	// when these identifers are translated

	// Here we translate and cast declarators, note that variable_declarator node is only served as an intermediate node
	// and we extrat the fields and assign them directly to result.
	translatedDeclarators, err := translateNodes(t, declarators, false /* shouldUngroup */)
	if err != nil {
		return nil, err
	}

	result := &mast.TempGroupNode{}
	for _, declarator := range translatedDeclarators {
		n, ok := declarator.(*mast.JavaVariableDeclarator)
		if !ok {
			return nil, err
		}

		temp := &mast.VariableDeclaration{
			Names:   []*mast.Identifier{n.Name},
			Type:    castType,
			Value:   n.Initializer,
			IsConst: mastutil.HasJavaModifier(castModifiers, mast.FinalMod),
			LangFields: &mast.JavaVariableDeclarationFields{
				Modifiers:  castModifiers,
				Dimensions: n.Dimensions,
			},
		}
		result.Nodes = append(result.Nodes, temp)
	}

	return result, nil
}

// addImplicitModifiers adds implicit (default) modifiers if they are
// not specified explicitly.
func addImplicitModifiers(n *ts.Node, modifiers []mast.Expression, inter bool) ([]mast.Expression, error) {
	if inter {
		// all fields defined in interfaces are (implicitly)
		// public, static, and final, even if these modifiers are not
		// explicitly defined
		needsPublic := true
		needsStatic := true
		needsFinal := true
		for _, mod := range modifiers {
			if lit, ok := mod.(*mast.JavaLiteralModifier); ok {
				if lit.Modifier == mast.PrivateMod || lit.Modifier == mast.ProtectedMod {
					return nil, fmt.Errorf("interface field declaration %T has unexpected identifier %q", n, lit.Modifier)
				}
				if lit.Modifier == mast.PublicMod {
					needsPublic = false
				}
				if lit.Modifier == mast.StaticMod {
					needsStatic = false
				}
				if lit.Modifier == mast.FinalMod {
					needsFinal = false
				}
			}
		}
		if needsPublic {
			modifiers = append(modifiers, &mast.JavaLiteralModifier{Modifier: mast.PublicMod})
		}
		if needsStatic {
			modifiers = append(modifiers, &mast.JavaLiteralModifier{Modifier: mast.StaticMod})
		}
		if needsFinal {
			modifiers = append(modifiers, &mast.JavaLiteralModifier{Modifier: mast.FinalMod})
		}
	}
	return modifiers, nil
}

// classDeclaration translates class_declaration to mast.JavaClassDeclaration.
func (t *JavaTranslator) classDeclaration(node *ts.Node) (mast.Node, error) {
	// class_declaration must have at least 2 children:
	// modifiers (optionasl, anonymous), name, type_parameters (optional), superclass (optional), interfaces (optional), body.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaClassDeclaration{}

	if node.Children[0].Type == "modifiers" {
		modifiers, err := translateModifiers(t, node.Children[0])
		if err != nil {
			return nil, err
		}
		result.Modifiers = modifiers
	}

	name, typeParameters := node.ChildByField("name"), node.ChildByField("type_parameters")
	superClass, interfaces, body := node.ChildByField("superclass"), node.ChildByField("interfaces"), node.ChildByField("body")

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	castName.Kind = mast.Typ
	result.Name = castName

	if typeParameters != nil {
		castTypeParameters, err := translateTypeParameters(t, typeParameters)
		if err != nil {
			return nil, err
		}
		result.TypeParameters = castTypeParameters
	}

	if superClass != nil {
		// translate and cast superclass
		translatedSuperClass, err := t.Translate(superClass)
		if err != nil {
			return nil, err
		}
		castSuperClass, ok := translatedSuperClass.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedSuperClass)
		}
		// just a reminder - expressions in a superclass declaration
		// are type identifiers (e.g., Clazz in class C extends
		// Clazz{}) or scoped type identifiers (e.g., Foo.Clazz in
		// class C extends Foo.Clazz{}) and are handled when these
		// identifers are translated
		result.SuperClass = castSuperClass
	}

	if interfaces != nil {
		// interfaces will be translated to multiple mast.Expression nodes grouped by mast.TempGroupNode (
		// e.g., "class Test implements A, B, C"). Therefore here we un-group them.
		translatedInterfaces, err := translateNodes(t, []*ts.Node{interfaces}, true /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castInterfaces, err := toExpressions(translatedInterfaces)
		if err != nil {
			return nil, err
		}
		// just a reminder - expressions in a superinterface
		// declaration are type identifiers (e.g., Inter in class C
		// implements Inter{}) or scoped type identifiers (e.g.,
		// Foo.Inter in class C implements Foo.Inter{}) and are
		// handled when these identifers are translated
		result.Interfaces = castInterfaces
	}

	castBody, err := translateClassBody(t, body)
	if err != nil {
		return nil, err
	}
	result.Body = castBody

	return result, nil
}

// staticInitializer translates static_initializer to mast.JavaStaticInitializer.
func (t *JavaTranslator) staticInitializer(node *ts.Node) (mast.Node, error) {
	// static_initializer must have 1 child: block (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	// translate and cast block
	translatedBlock, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	castBlock, ok := translatedBlock.(*mast.Block)
	if !ok {
		return nil, nodeTypeError(translatedBlock)
	}

	result := &mast.JavaClassInitializer{
		IsStatic: true,
		Block:    castBlock,
	}

	return result, nil
}

// methodDeclaration translates method_declaration/constructor_declaration to mast.FunctionDeclaration.
func (t *JavaTranslator) methodDeclaration(node *ts.Node) (mast.Node, error) {
	// method_declaration must have at least 2 children:
	// modifiers (optional, anonymous), type_parameters (optional), list of annotations (optional, anonymous),
	// type (optional), name, parameters, dimensions (optional), throws (optional, anonymous), body (optional).
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	// modifiers, type_parameters, type and list of annotations are all optional, anonymous, or both, which makes it
	// diffcult to translate. However, their types are somewhat unique so we first scan through the children and assign
	// the nodes based on their types.
	typeNode := node.ChildByField("type")
	name, parameters := node.ChildByField("name"), node.ChildByField("parameters")
	dimensions, body := node.ChildByField("dimensions"), node.ChildByField("body")

	// assert the nil-ness of children
	if name == nil || parameters == nil {
		return nil, nilChildError(node)
	}

	// put the pointer of the extra node on the result here so that later edits of the extra node will automatically be
	// reflected on the result.
	extra := &mast.JavaFunctionDeclarationFields{}
	result := &mast.FunctionDeclaration{LangFields: extra}

	var modifiers, typeParameters, throws *ts.Node
	var annotations []*ts.Node
	for _, child := range node.Children {
		switch child.Type {
		case "modifiers":
			modifiers = child
		case "type_parameters":
			typeParameters = child
		case "marker_annotation", "annotation":
			// marker_annotation is the simplified version of annotation which does not have annotation arguments (e.g.,
			// "@Test").
			annotations = append(annotations, child)
		case "throws":
			throws = child
		}
	}

	if modifiers != nil {
		castModifiers, err := translateModifiers(t, modifiers)
		if err != nil {
			return nil, err
		}
		extra.Modifiers = castModifiers
	}

	if typeParameters != nil {
		castTypeParameters, err := translateTypeParameters(t, typeParameters)
		if err != nil {
			return nil, err
		}
		// just a reminder - the kinds of type parameters are set
		// during type parameter translations
		extra.TypeParameters = castTypeParameters
	}

	if len(annotations) != 0 {
		castAnnotations, err := translateAnnotations(t, annotations)
		if err != nil {
			return nil, err
		}
		// just a reminder - the kinds of annotations are set during
		// annotation translations
		extra.Annotations = castAnnotations
	}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	castName.Kind = mast.Method
	result.Name = castName

	if typeNode != nil {
		// translate and cast type
		// Note that Java only allows a bare type as return type, therefore for better unification we convert it to
		// mast.ParameterDeclaration.
		translatedType, err := t.Translate(typeNode)
		if err != nil {
			return nil, err
		}
		castType, ok := translatedType.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedType)
		}
		// just a reminder - expressions in a method return type
		// declaration are type identifiers (e.g., Clazz bar(){}) or
		// scoped type identifiers (e.g., Foo.Clazz in Foo.Clazz
		// bar(){}) and are handled when these identifers are
		// translated
		returnParameter := &mast.ParameterDeclaration{
			Type:       castType,
			LangFields: &mast.JavaParameterDeclarationFields{},
		}
		result.Returns = append(result.Returns, returnParameter)
	}

	// translate and cast parameters
	if len(parameters.Children) != 0 {
		translatedParameters, err := translateNodes(t, parameters.Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		result.Parameters = make([]mast.Declaration, len(translatedParameters))
		for i, child := range translatedParameters {
			n, ok := child.(*mast.ParameterDeclaration)
			if !ok {
				return nil, nodeTypeError(child)
			}
			// just a reminder - the kinds of parameters are set during
			// parameter translations
			result.Parameters[i] = n
		}
	}

	if dimensions != nil {
		castDimensions, err := translateDimensions(t, dimensions)
		if err != nil {
			return nil, err
		}
		extra.Dimensions = castDimensions
	}

	if throws != nil {
		translatedThrows, err := translateNodes(t, throws.Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castThrows, err := toExpressions(translatedThrows)
		if err != nil {
			return nil, err
		}
		// just a reminder - expressions in a throws clause are type
		// identifiers (e.g., Clazz in throws Clazz) or scoped type
		// identifiers (e.g., Foo.Clazz in throws Foo.Clazz) and are
		// handled when these identifers are translated
		extra.Throws = castThrows
	}

	if body != nil {
		// translate and cast body
		translatedBody, err := t.Translate(body)
		if err != nil {
			return nil, err
		}
		castBody, ok := translatedBody.(*mast.Block)
		if !ok {
			return nil, nodeTypeError(translatedBody)
		}
		result.Statements = castBody.Statements
	}

	return result, err
}

// interfaceDeclaration translates interface_declaration to mast.InterfaceDeclaration.
func (t *JavaTranslator) interfaceDeclaration(node *ts.Node) (mast.Node, error) {
	// interface_declaration must have at least 2 children:
	// modifiers (optional, anonymous), name, type_parameters (optional), extends_interfaces (optional, anonymous), body.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	// collect the anonymous nodes first
	var modifiers, extends *ts.Node
	for _, child := range node.Children {
		switch child.Type {
		case "modifiers":
			modifiers = child
		case "extends_interfaces":
			extends = child
		}
	}
	// collect named nodes
	name, typeParameters, body := node.ChildByField("name"), node.ChildByField("type_parameters"), node.ChildByField("body")
	// only type_parameters is optional
	if name == nil || body == nil {
		return nil, nilChildError(node)
	}

	result := &mast.JavaInterfaceDeclaration{}

	if modifiers != nil {
		castModifiers, err := translateModifiers(t, modifiers)
		if err != nil {
			return nil, err
		}
		result.Modifiers = castModifiers
	}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	castName.Kind = mast.Typ
	result.Name = castName

	if typeParameters != nil {
		castParameters, err := translateTypeParameters(t, typeParameters)
		if err != nil {
			return nil, err
		}
		result.TypeParameters = castParameters
	}

	if extends != nil {
		// extends_interfaces has the following structure:
		// extends_interfaces
		//   - interface_type_list
		//     - type_identifier
		//     - annotated_type
		//         - annotation
		//         - type_identifier
		//     - type_identifier
		//     ...
		// even if there is only one interface to extend.
		// Therefore, we unwrap _twice_ here and directly skip "extends_interfaces" and "interface_type_list" nodes.
		if len(extends.Children) != 1 {
			return nil, fmt.Errorf("unexpected length of children for extends_interfaces: %v", len(extends.Children))
		}

		translatedExtends, err := translateNodes(t, extends.Children[0].Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castExtends, err := toExpressions(translatedExtends)
		if err != nil {
			return nil, err
		}
		// just a reminder - expressions in a superinterface
		// declaration are type identifiers (e.g., Inter in interface
		// I implements Inter{}) or scoped type identifiers (e.g.,
		// Foo.Inter in interface I implements Foo.Inter{}) and are
		// handled when these identifers are translated
		result.Extends = castExtends
	}

	if len(body.Children) != 0 {
		// interface_body contains multiple declaration nodes, here we directly unwrap and skip it and directly
		// translate its children.
		// The children might contain constant field declaration such as "public int a = 1, b = 2;" which would be
		// translated to multiple mast.FieldDeclaration nodes grouped by mast.TempGroupNode, therefore here we un-group
		// them.
		translatedBody, err := translateNodes(t, body.Children, true /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castBody, err := toDeclarations(translatedBody)
		if err != nil {
			return nil, err
		}
		result.Body = castBody
	}

	return result, nil
}

// explicitConstructorInvocation translates explicit_constructor_invocation to
// mast.CallExpression with extra mast.JavaCallExpressionFields for optional type
// arguments.
func (t *JavaTranslator) explicitConstructorInvocation(node *ts.Node) (mast.Node, error) {
	// explicit_constructor_invocation must have at least 2 children:
	// object (optional), type_arguments (optional), constructor, arguments.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	object, typeArguments := node.ChildByField("object"), node.ChildByField("type_arguments")
	constructor, arguments := node.ChildByField("constructor"), node.ChildByField("arguments")

	// tree-sitter will generate an "argument_list" node with no children for an invocation with no arguments, therefore
	// constructor and arguments cannot be nil.
	if constructor == nil || arguments == nil {
		return nil, nilChildError(node)
	}

	result := &mast.CallExpression{}

	// translate and cast constructor
	translatedConstructor, err := t.Translate(constructor)
	if err != nil {
		return nil, err
	}
	castConstructor, ok := translatedConstructor.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedConstructor)
	}
	// for consistency, let's mark the identifier as mast.Method here
	// so that the invariant of each CallExpression's function name
	// being marked as such holds
	castConstructor.Kind = mast.Method

	result.Function = castConstructor

	// object is an optional object for the constructor call (e.g., "pkg.A" in "pkg.A.super();"), therefore here if it
	// exists we put the object together with the Function field.
	if object != nil {
		// translate and cast object
		translatedObject, err := t.Translate(object)
		if err != nil {
			return nil, err
		}
		castObject, ok := translatedObject.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedObject)
		}
		result.Function = &mast.AccessPath{
			Operand: castObject,
			Field:   castConstructor,
		}
	}

	// translate and cast type arguments
	translatedTypeArguments, err := t.translateTypeArguments(typeArguments)
	if err != nil {
		return nil, err
	}
	if translatedTypeArguments != nil {
		fields := &mast.JavaCallExpressionFields{
			TypeArguments: translatedTypeArguments,
		}
		result.LangFields = fields
	}

	// Note that for invocations with no arguments tree-sitter will still generate an "argument_list" node with no
	// children. So we only proceed if it is not empty.
	if len(arguments.Children) != 0 {
		// argument_list is a wrapper node that wraps around a list of arguments, here we unwrap it by directly passing
		// arguments.Children.
		translatedArguments, err := translateNodes(t, arguments.Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castArguments, err := toExpressions(translatedArguments)
		if err != nil {
			return nil, err
		}
		result.Arguments = castArguments
	}

	return result, nil
}

// enumDeclaration translates enum_declaration to mast.JavaEnumDeclaration.
func (t *JavaTranslator) enumDeclaration(node *ts.Node) (mast.Node, error) {
	// enum_declaration must have at least 2 children:
	// modifiers (optional, anonymous), name, interfaces (optional), body.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaEnumDeclaration{}

	if node.Children[0].Type == "modifiers" {
		modifiers, err := translateModifiers(t, node.Children[0])
		if err != nil {
			return nil, err
		}
		result.Modifiers = modifiers
	}

	name, interfaces, body := node.ChildByField("name"), node.ChildByField("interfaces"), node.ChildByField("body")
	// name and body must exist
	if name == nil || body == nil {
		return nil, nilChildError(node)
	}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	if interfaces != nil {
		// interfaces have the following structure:
		// super_interfaces
		//   - interface_type_list
		//      - type_identifier
		//      - type_identifier
		//      ...
		// even if there is only one type. Therefore, here we unwrap _twice_ and
		// skip the super_interfaces and interface_type_list node.
		if len(interfaces.Children) != 1 {
			return nil, fmt.Errorf("unexpected length of children for super_interfaces: %v", len(interfaces.Children))
		}
		translatedInterfaces, err := translateNodes(t, interfaces.Children[0].Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castInterfaces, err := toExpressions(translatedInterfaces)
		if err != nil {
			return nil, err
		}
		result.Interfaces = castInterfaces
	}

	if len(body.Children) != 0 {
		// body is of type enum_body, which is a wrapper node around a list of enum_constant/method_declaration etc.
		// nodes. Here we unwrap it and skip the enum_body node.
		// The enum_body could contain enum_body_declarations, which is another wrapper node that wraps around multiple
		// declaration nodes.
		// enum A {
		//   a, b
		//   ;
		//   public void hello()   {}   <---|
		//   public void hello2()  {}       | These three nodes are wrapped inside enum_body_declarations node.
		//   public void hello3()  {}   <---|
		// }
		// This will be translated to mast.TempGroupNode and therefore we un-group them here.
		translatedBody, err := translateNodes(t, body.Children, true /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castBody, err := toDeclarations(translatedBody)
		if err != nil {
			return nil, err
		}
		result.Body = castBody
	}

	return result, nil
}

// enumConstant translates enum_constant to mast.JavaEnumConstantDeclaration.
func (t *JavaTranslator) enumConstant(node *ts.Node) (mast.Node, error) {
	// enum_constant must have at least 1 child:
	// modifiers (optional, anonymous), name, arguments (optional), body (optional).
	if len(node.Children) < 1 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaEnumConstantDeclaration{}

	if node.Children[0].Type == "modifiers" {
		castModifiers, err := translateModifiers(t, node.Children[0])
		if err != nil {
			return nil, err
		}
		result.Modifiers = castModifiers
	}

	name, arguments, body := node.ChildByField("name"), node.ChildByField("arguments"), node.ChildByField("body")
	// name must exist
	if name == nil {
		return nil, nilChildError(node)
	}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	if arguments != nil && len(arguments.Children) != 0 {
		// arguments is an argument_list node which is a wrapper node of a list of arguments, here we unwrap it.
		translatedArguments, err := translateNodes(t, arguments.Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castArguments, err := toExpressions(translatedArguments)
		if err != nil {
			return nil, err
		}
		result.Arguments = castArguments
	}

	if body != nil && len(body.Children) != 0 {
		// The body field is of type class_body, therefore we make use of the helper function here.
		castBody, err := translateClassBody(t, body)
		if err != nil {
			return nil, err
		}
		result.Body = castBody
	}

	return result, nil
}

// annotationTypeDeclaration translates annotation_type_declaration to mast.JavaAnnotationDeclaration.
func (t *JavaTranslator) annotationTypeDeclaration(node *ts.Node) (mast.Node, error) {
	// annotation_type_declaration must have at least 2 children: modifiers (optional, anonymous), name, body.
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaAnnotationDeclaration{}

	if node.Children[0].Type == "modifiers" {
		castModifiers, err := translateModifiers(t, node.Children[0])
		if err != nil {
			return nil, err
		}
		result.Modifiers = castModifiers
	}

	name, body := node.ChildByField("name"), node.ChildByField("body")
	// name and body must exist
	if name == nil || body == nil {
		return nil, nilChildError(node)
	}

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	result.Name = castName

	if len(body.Children) == 0 {
		return result, nil
	}

	// body is a annotation_type_body node which is a wrapper node of multiple declarations, therefore we unwrap it
	// here. Note that body might contain constant_declaration nodes which could be translated to multiple
	// mast.FieldDeclaration nodes grouped by mast.TempGroupNode (e.g, "int C = 1, D = 2;"). Here we un-group them.
	translatedDeclarations, err := translateNodes(t, body.Children, true /* shouldUngroup */)
	if err != nil {
		return nil, err
	}
	castDeclarations, err := toDeclarations(translatedDeclarations)
	if err != nil {
		return nil, err
	}
	result.Body = castDeclarations

	return result, nil
}

// annotationTypeElementDeclaration translates annotation_type_element_declaration to
// mast.JavaAnnotationElementDeclaration.
func (t *JavaTranslator) annotationTypeElementDeclaration(node *ts.Node) (mast.Node, error) {
	// annotation_type_element_declaration must have at least 2 children:
	// modifiers (optional, anonymous), type, name, dimensions (optional), value (optional).
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	result := &mast.JavaAnnotationElementDeclaration{}

	if node.Children[0].Type == "modifiers" {
		castModifiers, err := translateModifiers(t, node.Children[0])
		if err != nil {
			return nil, err
		}
		result.Modifiers = castModifiers
	}

	typeNode, name := node.ChildByField("type"), node.ChildByField("name")
	dimensions, value := node.ChildByField("dimensions"), node.ChildByField("value")
	// type and name must exist
	if typeNode == nil || name == nil {
		return nil, nilChildError(node)
	}

	// translate and cast type
	translatedType, err := t.Translate(typeNode)
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}
	result.Type = castType

	// translate and cast name
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}
	// mast.JavaAnnotationElementDeclaration is basically an interface
	// method call declaration tailored for annotation declaration
	// use-case
	castName.Kind = mast.Method

	result.Name = castName

	// translate and cast dimensions
	if dimensions != nil {
		castDimensions, err := translateDimensions(t, dimensions)
		if err != nil {
			return nil, err
		}
		result.Dimensions = castDimensions
	}

	if value != nil {
		// translate and cast value
		translatedValue, err := t.Translate(value)
		if err != nil {
			return nil, err
		}
		castValue, ok := translatedValue.(mast.Expression)
		if !ok {
			return nil, nodeTypeError(translatedValue)
		}
		result.Value = castValue
	}

	return result, nil
}

// resource translates resource to either
// (1) mast.Identifier or mast.AccessPath wrapped in mast.ExpressionStatement;
// (2) mast.VariableDeclaration wrapped in mast.DeclarationStatement.
func (t *JavaTranslator) resource(node *ts.Node) (mast.Node, error) {
	// resource has one of the following forms:
	// (1) an Identifier or an AccessPath;
	// (2) modifiers (optional, anonymous), type, name, dimensions (optional), value.
	if (len(node.Children) < 3 || len(node.Children) > 5) && len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	// directly wrap the Identifier or AccessPath in mast.ExpressionStatement
	if len(node.Children) == 1 {
		// translate and cast variable
		translatedVariable, err := t.Translate(node.Children[0])
		if err != nil {
			return nil, err
		}
		// assert that variable has type mast.Identifier or mast.AccessPath
		var castVariable mast.Expression
		switch n := translatedVariable.(type) {
		case *mast.Identifier:
			castVariable = n
		case *mast.AccessPath:
			castVariable = n
		default:
			return nil, nodeTypeError(translatedVariable)
		}
		result := &mast.ExpressionStatement{
			Expr: castVariable,
		}
		return result, nil
	}

	// Otherwise, we create a mast.VariableDeclaration node and wrap it inside mast.DeclarationStatement.
	var modifiers *ts.Node
	if node.Children[0].Type == "modifiers" {
		modifiers = node.Children[0]
	}

	typeNode, name := node.ChildByField("type"), node.ChildByField("name")
	dimensions, value := node.ChildByField("dimensions"), node.ChildByField("value")

	// create mast.VariableDeclaration
	declaration, err := translateVariableDeclaration(t, modifiers, typeNode, name, dimensions, value)
	if err != nil {
		return nil, err
	}

	// return the wrapped node
	result := &mast.DeclarationStatement{
		Decl: declaration,
	}

	return result, nil
}

// methodReference translates method_reference to mast.JavaMethodReference.
func (t *JavaTranslator) methodReference(node *ts.Node) (mast.Node, error) {
	// method_reference must have 1-3 children:
	// class (anonymous), type_arguments (optional, anonymous), name (anonymous).
	// Note that the method name could optionally be "new", which is a terminal keyword. In that case, our tree-sitter
	// library will not include it in Children, and we will have to create a mast.Identifier node for it.
	if len(node.Children) < 1 || len(node.Children) > 3 {
		return nil, childrenNumberError(node)
	}

	var class, typeArguments, name *ts.Node
	// iterate through Children and assign the local variables based on each child's type
	for _, child := range node.Children {
		// Everything except type_arguments node should be class or name, in the given order. So we only assign name
		// if class is nil.
		if child.Type == "type_arguments" {
			typeArguments = child
		} else if class == nil {
			class = child
		} else {
			name = child
		}
	}
	// class must exist
	if class == nil {
		return nil, nilChildError(node)
	}

	result := &mast.JavaMethodReference{}

	// translate and cast class
	translatedClass, err := t.Translate(class)
	if err != nil {
		return nil, err
	}
	castClass, ok := translatedClass.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedClass)
	}
	result.Class = castClass

	result.TypeArguments, err = t.translateTypeArguments(typeArguments)
	if err != nil {
		return nil, err
	}

	// name cannot be nil, if it happens it means that the method is "new".
	if name == nil {
		// for consistency across method references, let's mark "new"
		// as a method here as we would normally mark a more
		// "ordinary" method name appearing after ::
		result.Method = &mast.Identifier{Name: "new", Kind: mast.Method}
		return result, nil
	}

	// Otherwise, translate and cast name.
	translatedName, err := t.Translate(name)
	if err != nil {
		return nil, err
	}
	castName, ok := translatedName.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedName)
	}

	// only a method name (or "new" - see above) can appear after ::
	// in a method reference expression
	castName.Kind = mast.Method

	result.Method = castName

	return result, nil
}

// translateTypeArguments is a helper function that translates
// type_arguments node (representing types in generic
// type instantiations) to a slice of mast.Expression nodes (normally
// in tree-sitter represented by type identifiers or scoped type
// identifiers).
func (t *JavaTranslator) translateTypeArguments(typeArguments *ts.Node) ([]mast.Expression, error) {
	if typeArguments != nil && len(typeArguments.Children) != 0 {
		// type_arguments is a wrapper node that wraps around a list of types, here we unwrap it and directly attach the
		// translated children to the TypeArguments field.
		translatedTypeArguments, err := translateNodes(t, typeArguments.Children, false /* shouldUngroup */)
		if err != nil {
			return nil, err
		}
		castTypeArguments, err := toExpressions(translatedTypeArguments)
		if err != nil {
			return nil, err
		}
		return castTypeArguments, nil
	}
	return nil, nil
}

// classLiteral translates class_literal to mast.JavaClassLiteral.
func (t *JavaTranslator) classLiteral(node *ts.Node) (mast.Node, error) {
	// class_literal must have 1 child: type (anonymous).
	if len(node.Children) != 1 {
		return nil, childrenNumberError(node)
	}

	translatedType, err := t.Translate(node.Children[0])
	if err != nil {
		return nil, err
	}
	castType, ok := translatedType.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedType)
	}

	result := &mast.JavaClassLiteral{Type: castType}
	return result, nil
}

// scopedTypeIdentifier translates scoped_type_identifier to mast.AccessPath.
func (t *JavaTranslator) scopedTypeIdentifier(node *ts.Node) (mast.Node, error) {
	// scoped_type_identifier must have at least 2 children:
	// operand (anonymous), multiple annotations (optional, anonymous), field (anonymous).
	if len(node.Children) < 2 {
		return nil, childrenNumberError(node)
	}

	// scoped_type_identifier is the same as scoped_identifier or field_access in Java, except that it allows multiple
	// annotation nodes between the operand and the field.
	// See https://docs.oracle.com/javase/specs/jls/se11/html/jls-4.html#jls-4.3 for a detailed explanation.

	result := &mast.AccessPath{}

	// The first element must be the operand and the last element must be the field.
	operand, field := node.Children[0], node.Children[len(node.Children)-1]
	var annotations []*ts.Node
	if len(node.Children) > 2 {
		annotations = node.Children[1 : len(node.Children)-1]
	}

	// translate and cast operand
	translatedOperand, err := t.Translate(operand)
	if err != nil {
		return nil, err
	}
	castOperand, ok := translatedOperand.(mast.Expression)
	if !ok {
		return nil, nodeTypeError(translatedOperand)
	}
	result.Operand = castOperand

	// translate and cast field
	translatedField, err := t.Translate(field)
	if err != nil {
		return nil, err
	}
	castField, ok := translatedField.(*mast.Identifier)
	if !ok {
		return nil, nodeTypeError(translatedField)
	}
	result.Field = castField

	// translate and cast anntations
	if len(annotations) != 0 {
		castAnnotations, err := translateAnnotations(t, annotations)
		if err != nil {
			return nil, err
		}
		result.Annotations = castAnnotations
	}

	return result, nil
}
